<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>xibs.analytical &mdash; xibs 0.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-codeautolink.css?v=125d5c1c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-dropdown.css?v=995e94df" />
      <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.min.css?v=21c0b90a" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=0a86e678" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8fa8b3e9"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
          </a>
              <div class="version">
                0.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#integration-with-xsuite">Integration with xsuite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#formalism-and-models">Formalism and Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#analytical-calculations">Analytical Calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#providing-kicks-to-particle-distributions">Providing Kicks to Particle Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#formalism-dispatch">Formalism Dispatch</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html">Bjorken-Mtingwa Formalism - Analytical Growth Rates and Emittance Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#computing-ibs-growth-rates">Computing IBS Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#computing-new-emittances-from-growth-rates">Computing New Emittances from Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#analytical-evolution-for-a-time-period">Analytical Evolution for a Time Period</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_compare_analyticals.html">Comparison of Analytical IBS Growth Rates and Emittances Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_compare_analyticals.html#comparing-analytical-evolution-for-a-time-period">Comparing Analytical Evolution for a Time Period</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html">Nagaitsev Formalism - Analytical Growth Rates and Emittance Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#computing-elliptic-integrals-and-ibs-growth-rates">Computing Elliptic Integrals and IBS Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#computing-new-emittances-from-growth-rates">Computing New Emittances from Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#analytical-evolution-for-many-turns">Analytical Evolution for Many Turns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_simple_kicks.html">Simple Kicks Formalism - IBS Kicks Based on Analytical Growth Rates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#generating-the-ibs-kick-class">Generating the IBS Kick Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#computing-and-applying-ibs-kicks">Computing and Applying IBS Kicks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#applying-ibs-kicks-in-tracking">Applying IBS Kicks in Tracking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#input-data-structures">Input Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#formalism-dispatch">Formalism Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#ibs-analytical-calculations">IBS: Analytical Calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#ibs-applying-kicks">IBS: Applying Kicks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#formulary">Formulary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/index.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../faq/input_parameters.html">Instantiating Input Parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#opticsparameters-from-an-xtrack-line">OpticsParameters from an <code class="xref py py-obj docutils literal notranslate"><span class="pre">xtrack.Line</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#opticsparameters-from-mad-x">OpticsParameters from <code class="docutils literal notranslate"><span class="pre">MAD-X</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#do-i-need-a-full-matched-particle-distribution-for-beamparameters">Do I need a full matched particle distribution for <code class="xref py py-obj docutils literal notranslate"><span class="pre">BeamParameters</span></code>?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#beamparameters-from-an-xtrack-line">BeamParameters from an <code class="xref py py-obj docutils literal notranslate"><span class="pre">xtrack.Line</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#beamparameters-from-mad-x">BeamParameters from <code class="docutils literal notranslate"><span class="pre">MAD-X</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/emittance_types.html">Emittances: Geometric or Normalized</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/radiation.html">Synchrotron Radiation Contribution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faq/radiation.html#getting-sr-parameters-from-xsuite">Getting SR Parameters from Xsuite</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/radiation.html#getting-sr-parameters-from-mad-x">Getting SR Parameters from MAD-X</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/coasting_beams.html">Bunched and Coasting Beams</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Reference Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">xibs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">xibs.analytical</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for xibs.analytical</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. _xibs-analytical:</span>

<span class="sd">IBS: Analytical Calculations</span>
<span class="sd">----------------------------</span>

<span class="sd">Module with functionality to perform analytical IBS calculations, either according to either Nagaitsev&#39;s or Bjorken &amp; Mtingwa&#39;s formalism.</span>
<span class="sd">User-facing classes are provided which allow to compute the growth rates based on beam parameters and machine optics.</span>
<span class="sd">The formalism from which formulas and calculations are implemented can be found in :cite:p:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation` and :cite:`CERN:Antoniou:Revision_IBS_MADX`, respectively.</span>

<span class="sd">.. warning::</span>
<span class="sd">    Please note that these analytical implementations make the assumptions.</span>
<span class="sd">    Should your scenario not satisfy the following assumptions, the results might not be accurate:</span>

<span class="sd">        - It is assumed that beam profiles are Gaussian,</span>
<span class="sd">        - It is assumed that no betatron coupling is present in the machine (or very little, in the order of :math:`\left| C^{-} \right| \le 10^{-4}`).</span>

<span class="sd">    Should these assumptions not be satisfied, the results provided by these calculations are not to be entirely discarded but might not be totally accurate.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>  <span class="c1"># important for sphinx to alias ArrayLike</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">astuple</span><span class="p">,</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">c</span><span class="p">,</span> <span class="n">hbar</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span><span class="p">,</span> <span class="n">quad_vec</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">elliprd</span>

<span class="kn">from</span> <span class="nn">xibs.formulary</span> <span class="kn">import</span> <span class="n">phi</span>
<span class="kn">from</span> <span class="nn">xibs.inputs</span> <span class="kn">import</span> <span class="n">BeamParameters</span><span class="p">,</span> <span class="n">OpticsParameters</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># ----- Dataclasses to store results ----- #</span>


<div class="viewcode-block" id="NagaitsevIntegrals">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.NagaitsevIntegrals">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">NagaitsevIntegrals</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.2.0</span>

<span class="sd">    Container dataclass for Nagaitsev integrals results.</span>

<span class="sd">    Args:</span>
<span class="sd">        Ix (float): horizontal Nagaitsev integral.</span>
<span class="sd">        Iy (float): vertical Nagaitsev integral.</span>
<span class="sd">        Iz (float): longitudinal Nagaitsev integral.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Ix</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Iy</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Iz</span><span class="p">:</span> <span class="nb">float</span></div>



<div class="viewcode-block" id="IBSGrowthRates">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.IBSGrowthRates">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">IBSGrowthRates</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.2.0</span>

<span class="sd">    Container dataclass for IBS growth rates results.</span>

<span class="sd">    Args:</span>
<span class="sd">        Tx (float): horizontal IBS growth rate.</span>
<span class="sd">        Ty (float): vertical IBS growth rate.</span>
<span class="sd">        Tz (float): longitudinal IBS growth rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Tx</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Ty</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Tz</span><span class="p">:</span> <span class="nb">float</span></div>



<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">_SynchrotronRadiationInputs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.6.0</span>

<span class="sd">    Container dataclass for SR input into emittance evolutions.</span>

<span class="sd">    Args:</span>
<span class="sd">        equilibrium_epsx (float): the horizontal equilibrium emittance from synchrotron radiation and quantum excitation in [m].</span>
<span class="sd">        equilibrium_epsy (float): the vertical equilibrium emittance from synchrotron radiation and quantum excitation in [m].</span>
<span class="sd">        equilibrium_sigma_delta (float): the equilibrium momentum spread from synchrotron radiation and quantum excitation.</span>
<span class="sd">        tau_x (float): the horizontal damping time from synchrotron radiation, in [s].</span>
<span class="sd">        tau_y (float): the vertical damping time from synchrotron radiation, in [s].</span>
<span class="sd">        tau_z (float): the longitudinal damping time from synchrotron radiation, in [s].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">equilibrium_epsx</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">equilibrium_epsy</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">equilibrium_sigma_delta</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tau_x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tau_y</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tau_z</span><span class="p">:</span> <span class="nb">float</span>


<span class="c1"># ----- Abstract Base Class to Inherit from ----- #</span>


<div class="viewcode-block" id="AnalyticalIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.AnalyticalIBS">[docs]</a>
<span class="k">class</span> <span class="nc">AnalyticalIBS</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.4.0</span>

<span class="sd">    Abstract base class for analytical IBS calculations, from which all</span>
<span class="sd">    implementations inherit.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for the calculations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the calculations.</span>
<span class="sd">        ibs_growth_rates (IBSGrowthRates): the computed IBS growth rates. This self-updates</span>
<span class="sd">            when they are computed with the `growth_rates` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span> <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="p">:</span> <span class="n">BeamParameters</span> <span class="o">=</span> <span class="n">beam_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span> <span class="o">=</span> <span class="n">optics</span>
        <span class="c1"># This one self-updates when computed, but can be overwritten by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="p">:</span> <span class="n">IBSGrowthRates</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">has_growth_rates</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="p">,</span> <span class="n">IBSGrowthRates</span>
        <span class="p">)</span>  <span class="c1"># False if default for value of None</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object for analytical IBS calculations.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;IBS growth rates computed: </span><span class="si">{</span><span class="n">has_growth_rates</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="AnalyticalIBS.coulomb_log">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.AnalyticalIBS.coulomb_log">[docs]</a>
    <span class="k">def</span> <span class="nf">coulomb_log</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">        Calculates the Coulomb logarithm based on the beam parameters and optics the class</span>
<span class="sd">        was initiated with. For a good introductory resource on the Coulomb Log, see:</span>
<span class="sd">        https://docs.plasmapy.org/en/stable/notebooks/formulary/coulomb.html.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function follows the formulae in :cite:`AIP:Anderson:Physics_Vade_Mecum`. The</span>
<span class="sd">            Coulomb log is computed as :math:`\ln \left( \Lambda \right) = \ln(r_{max} / r_{min})`.</span>
<span class="sd">            Here :math:`r_{max}` denotes the smaller of :math:`\sigma_x` and the Debye length; while</span>
<span class="sd">            :math:`r_{min}` is the larger of the classical distance of closest approach and the</span>
<span class="sd">            quantum diffraction limit from the nuclear radius. It is the calculation that is done by</span>
<span class="sd">            ``MAD-X`` (see the `twclog` subroutine in the `MAD-X/src/ibsdb.f90` source file).</span>

<span class="sd">        .. note::</span>
<span class="sd">            Both geometric or normalized emittances can be given as input to this function, and it is assumed</span>
<span class="sd">            the user provides geomettric emittances. If normalized ones are given the `normalized_emittances`</span>
<span class="sd">            parameter should be set to `True` (it defaults to `False`). Internally, a conversion is done to</span>
<span class="sd">            geometric emittances, which are used in the computations.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`.</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The dimensionless Coulomb logarithm :math:`\ln \left( \Lambda \right)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Coulomb logarithm for defined beam and optics parameters&quot;</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we are working with geometric emittances</span>
        <span class="n">geom_epsx</span> <span class="o">=</span> <span class="n">epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsx</span><span class="p">)</span>
        <span class="n">geom_epsy</span> <span class="o">=</span> <span class="n">epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Interpolated beta and dispersion functions for the average calculation below</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Interpolating beta and dispersion functions&quot;</span><span class="p">)</span>
        <span class="n">_bxb</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">)</span>
        <span class="n">_byb</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">)</span>
        <span class="n">_dxb</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">_dyb</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing &quot;average&quot; of these functions - better here than a simple np.mean</span>
        <span class="c1"># calculation because the latter doesn&#39;t take in consideration element lengths</span>
        <span class="c1"># and can be skewed by some very high peaks in the optics</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>  <span class="c1"># Catch and ignore the scipy.integrate.IntegrationWarning</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
            <span class="n">_bx_bar</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">_bxb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
            <span class="n">_by_bar</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">_byb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
            <span class="n">_dx_bar</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">_dxb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
            <span class="n">_dy_bar</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">_dyb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Calculate transverse temperature as 2*P*X, i.e. assume the transverse energy is temperature/2</span>
        <span class="c1"># fmt: off</span>
        <span class="n">Etrans</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">5e8</span>
            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>
               <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">total_energy_eV</span> <span class="o">*</span> <span class="mf">1e-9</span>  <span class="c1"># total energy needed in GeV</span>
               <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_mass_eV</span> <span class="o">*</span> <span class="mf">1e-9</span>  <span class="c1"># particle mass needed in GeV</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">geom_epsx</span> <span class="o">/</span> <span class="n">_bx_bar</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="n">TempeV</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Etrans</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute sigmas in each dimension</span>
        <span class="n">sigma_x_cm</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">geom_epsx</span> <span class="o">*</span> <span class="n">_bx_bar</span> <span class="o">+</span> <span class="p">(</span><span class="n">_dx_bar</span> <span class="o">*</span> <span class="n">sigma_delta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sigma_y_cm</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">geom_epsy</span> <span class="o">*</span> <span class="n">_by_bar</span> <span class="o">+</span> <span class="p">(</span><span class="n">_dy_bar</span> <span class="o">*</span> <span class="n">sigma_delta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sigma_t_cm</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">bunch_length</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Calculate beam volume to get density (in cm^{-3}) then Debye length</span>
        <span class="k">if</span> <span class="n">bunched</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># bunched beam</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_x_cm</span> <span class="o">*</span> <span class="n">sigma_y_cm</span> <span class="o">*</span> <span class="n">sigma_t_cm</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># coasting beam</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma_x_cm</span> <span class="o">*</span> <span class="n">sigma_y_cm</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
        <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">n_part</span> <span class="o">/</span> <span class="n">volume</span>
        <span class="n">debyul</span> <span class="o">=</span> <span class="mf">743.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TempeV</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_charge</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Calculate &#39;rmin&#39; as larger of classical distance of closest approach or quantum mechanical</span>
        <span class="c1"># diffraction limit from nuclear radius</span>
        <span class="n">rmincl</span> <span class="o">=</span> <span class="mf">1.44e-7</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_charge</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">TempeV</span>
        <span class="n">rminqm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">hbar</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">1e5</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2e-3</span> <span class="o">*</span> <span class="n">Etrans</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_mass_eV</span> <span class="o">*</span> <span class="mf">1e-9</span><span class="p">))</span>
        <span class="p">)</span>  <span class="c1"># energy in GeV</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Now compute the impact parameters and finally Coulomb logarithm</span>
        <span class="n">bmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rmincl</span><span class="p">,</span> <span class="n">rminqm</span><span class="p">)</span>
        <span class="n">bmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sigma_x_cm</span><span class="p">,</span> <span class="n">debyul</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bmax</span> <span class="o">/</span> <span class="n">bmin</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnalyticalIBS.growth_rates">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.AnalyticalIBS.growth_rates">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">growth_rates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSGrowthRates</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to compute the IBS growth rates.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`.</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `IBSGrowthRates` object with the computed growth rates for each plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method should be implemented in all child classes, but it hasn&#39;t been for this one.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AnalyticalIBS.emittance_evolution">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.AnalyticalIBS.emittance_evolution">[docs]</a>
    <span class="k">def</span> <span class="nf">emittance_evolution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">        Analytically computes the new emittances after a given time step `dt` has</span>
<span class="sd">        ellapsed, from initial values, based on the ``IBS`` growth rates.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This calculation is done by building on the ``IBS`` growth rates. If the</span>
<span class="sd">            latter have not been computed yet, this method will raise an error. Please</span>
<span class="sd">            remember to call the instance&#39;s `growth_rates` method first.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is an exponential growth based on the rates :math:`T_{x,y,z}`. It goes</span>
<span class="sd">            according to the following, where :math:`N` represents the time step:</span>

<span class="sd">            .. math::</span>

<span class="sd">                T_{x,y,z} &amp;= 1 / \tau_{x,y,z}</span>

<span class="sd">                \varepsilon_{x,y}^{N+1} &amp;= \varepsilon_{x,y}^{N} * e^{t / \tau_{x,y}}</span>

<span class="sd">                \sigma_{\delta, z}^{N+1} &amp;= \sigma_{\delta, z}^{N} * e^{t / 2 \tau_{z}}</span>

<span class="sd">        .. note::</span>
<span class="sd">            Both geometric or normalized emittances can be given as input to this function, and it is assumed</span>
<span class="sd">            the user provides geomettric emittances. If normalized ones are given the `normalized_emittances`</span>
<span class="sd">            parameter should be set to `True` (it defaults to `False`). Internally, a conversion is done to</span>
<span class="sd">            geometric emittances, which are used in the computations. The returned emittances correspond to</span>
<span class="sd">            the type of those provided: if given normalized emittances this function will return values that</span>
<span class="sd">            correspond to the new normalized emittances.</span>


<span class="sd">        .. admonition:: Synchrotron Radiation</span>

<span class="sd">            Synchrotron Radiation can play a significant role in the evolution of the emittances</span>
<span class="sd">            in certain scenarios, particularly for leptons. One can include the contribution of</span>
<span class="sd">            SR to this calculation by providing several keyword arguments corresponding to the</span>
<span class="sd">            equilibrium emittances and damping times from SR and quantum excitation. See the list</span>
<span class="sd">            of expected kwargs below. A :ref:`dedicated section in the FAQ &lt;xibs-faq-sr-inputs&gt;`</span>
<span class="sd">            provides information on how to obtain these values from ``Xsuite`` or ``MAD-X``.</span>

<span class="sd">            In case this contribution is included, then the calculation is modified from the one</span>
<span class="sd">            shown above, and goes according to :cite:`BOOK:Wolski:Beam_dynamics` (Eq (13.64)) or</span>
<span class="sd">            :cite:`CAS:Martini:IBS_Anatomy_Theory` (Eq (135)):</span>

<span class="sd">            .. math::</span>

<span class="sd">                T_{x,y,z} &amp;= 1 / \tau_{x,y,z}^{\mathrm{IBS}}</span>

<span class="sd">                \varepsilon_{x,y}^{N+1} &amp;= \left[ - \varepsilon_{x,y}^{\mathrm{SR}eq} + \left( \varepsilon_{x,y}^{\mathrm{SR}eq} + \frac{\varepsilon_{x,y}^{N}}{2 \tau_{x,y}^{\mathrm{IBS}}} \tau_{x,y}^{\mathrm{SR}} - 1 \right) * e^{2 t \left( \frac{1}{2 \tau_{x,y}^{\mathrm{IBS}}} - \frac{1}{\tau_{x,y}^{\mathrm{SR}}} \right)} \right] / \left( \frac{\tau_{x,y}^{\mathrm{SR}}}{2 \tau_{x,y}^{\mathrm{IBS}}} - 1 \right)</span>

<span class="sd">                {\sigma_{\delta, z}^{N+1}}^2 &amp;= \left[ - {\sigma_{\delta, z}^{\mathrm{SR}eq}}^2 + \left( {\sigma_{\delta, z}^{\mathrm{SR}eq}}^2 + \frac{{\sigma_{\delta, z}^{N}}^2}{2 \tau_{z}^{\mathrm{IBS}}} \tau_{z}^{\mathrm{SR}} - 1 \right) * e^{2 t \left( \frac{1}{2 \tau_{z}^{\mathrm{IBS}}} - \frac{1}{\tau_{z}^{\mathrm{SR}}} \right)} \right] / \left( \frac{\tau_{z}^{\mathrm{SR}}}{2 \tau_{z}^{\mathrm{IBS}}} - 1 \right)</span>


<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            dt (float, optional): the time interval to use, in [s]. Default to the inverse</span>
<span class="sd">                of the revolution frequency, :math:`1 / f_{rev}`.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>
<span class="sd">            **kwargs: If keyword arguments are provided, they are considered inputs for the</span>
<span class="sd">                inclusion of synchrotron radiation in the calculation, and the following are</span>
<span class="sd">                expected, case-insensitively:</span>

<span class="sd">                    - `sr_equilibrium_epsx` (float)</span>
<span class="sd">                        the horizontal equilibrium emittance from synchrotron radiation</span>
<span class="sd">                        and quantum excitation, in [m]. Should be the same type (geometric</span>
<span class="sd">                        or normalized) as `epsx` and `epsy`.</span>

<span class="sd">                    - `sr_equilibrium_epsy` (float)</span>
<span class="sd">                        the vertical equilibrium emittance from synchrotron radiation and</span>
<span class="sd">                        quantum excitation, in [m]. Should be the same type (geometric or</span>
<span class="sd">                        normalized) as `epsx` and `epsy`.</span>

<span class="sd">                    - `sr_equilibrium_sigma_delta` (float)</span>
<span class="sd">                        the equilibrium momentum spread from synchrotron radiation and</span>
<span class="sd">                        quantum excitation.</span>

<span class="sd">                    - `sr_tau_x` (float)</span>
<span class="sd">                        the horizontal damping time from synchrotron radiation, in [s]</span>
<span class="sd">                        (should be the same unit as `dt`).</span>

<span class="sd">                    - `sr_tau_y` (float)</span>
<span class="sd">                        the vertical damping time from synchrotron radiation, in [s]</span>
<span class="sd">                        (should be the same unit as `dt`).</span>

<span class="sd">                    - `sr_tau_z` (float)</span>
<span class="sd">                        the longitudinal damping time from synchrotron radiation, in [s]</span>
<span class="sd">                        (should be the same unit as `dt`).</span>


<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: if the ``IBS`` growth rates have not yet been computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with the new horizontal &amp; vertical geometric emittances, the new</span>
<span class="sd">            momentum spread and the new bunch length, after the time step has ellapsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Check the kwargs and potentially get the arguments to include synchrotron radiation</span>
        <span class="n">include_synchrotron_radiation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># lets&#39; not check with &#39;is not None&#39; since default {} kwargs is not None</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Kwargs present, assuming synchrotron radiation is to be included&quot;</span><span class="p">)</span>
            <span class="n">include_synchrotron_radiation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sr_inputs</span><span class="p">:</span> <span class="n">_SynchrotronRadiationInputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_synchrotron_radiation_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we are working with geometric emittances (also for SR inputs if given)</span>
        <span class="n">geom_epsx</span> <span class="o">=</span> <span class="n">epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsx</span><span class="p">)</span>
        <span class="n">geom_epsy</span> <span class="o">=</span> <span class="n">epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_synchrotron_radiation</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sr_eq_geom_epsx</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sr_inputs</span><span class="o">.</span><span class="n">equilibrium_epsx</span>
                <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">sr_inputs</span><span class="o">.</span><span class="n">equilibrium_epsx</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">sr_eq_geom_epsy</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sr_inputs</span><span class="o">.</span><span class="n">equilibrium_epsy</span>
                <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">sr_inputs</span><span class="o">.</span><span class="n">equilibrium_epsy</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">sr_eq_sigma_delta</span> <span class="o">=</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">equilibrium_sigma_delta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Check that the IBS growth rates have been computed beforehand</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Attempted to compute emittance evolution without having computed growth rates.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;IBS growth rates have not been computed yet, cannot compute new emittances.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Please call the `growth_rates` method first.&quot;</span>
            <span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing new emittances from IBS growth rates for defined beam and optics parameters&quot;</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Set the time step to 1 / frev if not provided</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No time step provided, defaulting to 1 / frev&quot;</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">revolution_frequency</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute new emittances and return them. Here we multiply because T = 1 / tau</span>
        <span class="c1"># fmt: off</span>
        <span class="k">if</span> <span class="n">include_synchrotron_radiation</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># the basic calculation</span>
            <span class="n">new_epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tx</span><span class="p">)</span>
            <span class="n">new_epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Ty</span><span class="p">)</span>
            <span class="n">new_sigma_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span><span class="p">)</span>
            <span class="n">new_bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">bunch_length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># the modified calculation with Synchrotron Radiation contribution</span>
            <span class="n">new_epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span> <span class="n">sr_eq_geom_epsx</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">sr_eq_geom_epsx</span> <span class="o">+</span> <span class="n">geom_epsx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_x</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_x</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span> <span class="n">sr_eq_geom_epsy</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">sr_eq_geom_epsy</span> <span class="o">+</span> <span class="n">geom_epsy</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Ty</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Ty</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_y</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Ty</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># For longitudinal properties, compute the square to avoid too messy code</span>
            <span class="n">new_sigma_delta_square</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">sr_eq_sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">sr_eq_sigma_delta</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_bunch_length_square</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">sr_eq_sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">sr_eq_sigma_delta</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bunch_length</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span><span class="o">.</span><span class="n">Tz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sr_inputs</span><span class="o">.</span><span class="n">tau_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># And then simply get the square root of that for the final results</span>
            <span class="n">new_sigma_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">new_sigma_delta_square</span><span class="p">)</span>
            <span class="n">new_bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">new_bunch_length_square</span><span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we return the same type of emittances as the user provided</span>
        <span class="n">new_epsx</span> <span class="o">=</span> <span class="n">new_epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_emittance</span><span class="p">(</span><span class="n">new_epsx</span><span class="p">)</span>
        <span class="n">new_epsy</span> <span class="o">=</span> <span class="n">new_epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_emittance</span><span class="p">(</span><span class="n">new_epsy</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_epsx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_epsy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_sigma_delta</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_bunch_length</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_normalized_emittance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometric_emittance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.4.0</span>

<span class="sd">        Computes normalized emittance from the geometric one, using relativistic</span>
<span class="sd">        beta and gamma from the the instance&#39;s beam parameters attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            geometric_emittance (float): geometric emittance in [m].</span>
<span class="sd">            beta_ref (float): relativistic beta.</span>
<span class="sd">            gamma_rel (float): relativistic gamma.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The normalized emittance in [m].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">geometric_emittance</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>

    <span class="k">def</span> <span class="nf">_geometric_emittance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalized_emittance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.4.0</span>

<span class="sd">        Computes geometric emittance from the normalized one, using relativistic</span>
<span class="sd">        beta and gamma from the the instance&#39;s beam parameters attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            normalized_emittance (float): normalized emittance in [m].</span>
<span class="sd">            beta_ref (float): relativistic beta.</span>
<span class="sd">            gamma_rel (float): relativistic gamma.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The geometric emittance in [m].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">normalized_emittance</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_synchrotron_radiation_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SynchrotronRadiationInputs</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.6.0</span>

<span class="sd">        Called in `.emittance_evolution`. Gets the expected synchrotron radiation kwargs,</span>
<span class="sd">        and returns them as a dataclass. Will first convert to lowercase so the user does</span>
<span class="sd">        not have to worry about this.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: if any of the expected kwargs is not provided.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The parsed keyword arguments as a `_SynchrotronRadiationInputs` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lowercase_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">expected_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;sr_equilibrium_epsx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sr_equilibrium_epsy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sr_equilibrium_sigma_delta&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sr_tau_x&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sr_tau_y&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sr_tau_z&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lowercase_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">expected_keys</span><span class="p">):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Missing expected synchrotron radiation kwargs, see raised error message.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Not all expected synchrotron radiationkwargs were provided.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected: </span><span class="si">{</span><span class="n">expected_keys</span><span class="si">}</span><span class="s2">, provided: </span><span class="si">{</span><span class="n">lowercase_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_SynchrotronRadiationInputs</span><span class="p">(</span>
            <span class="n">equilibrium_epsx</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_equilibrium_epsx&quot;</span><span class="p">],</span>
            <span class="n">equilibrium_epsy</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_equilibrium_epsy&quot;</span><span class="p">],</span>
            <span class="n">equilibrium_sigma_delta</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_equilibrium_sigma_delta&quot;</span><span class="p">],</span>
            <span class="n">tau_x</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_tau_x&quot;</span><span class="p">],</span>
            <span class="n">tau_y</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_tau_y&quot;</span><span class="p">],</span>
            <span class="n">tau_z</span><span class="o">=</span><span class="n">lowercase_kwargs</span><span class="p">[</span><span class="s2">&quot;sr_tau_z&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>



<span class="c1"># ----- Classes to Compute Analytical IBS Growth Rates ----- #</span>


<div class="viewcode-block" id="NagaitsevIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.NagaitsevIBS">[docs]</a>
<span class="k">class</span> <span class="nc">NagaitsevIBS</span><span class="p">(</span><span class="n">AnalyticalIBS</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.2.0</span>

<span class="sd">    A single class to compute Nagaitsev integrals (see</span>
<span class="sd">    :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`)</span>
<span class="sd">    and IBS growth rates. It initiates from a `BeamParameters` and an `OpticsParameters` objects.</span>

<span class="sd">    See the :ref:`Nagaitsev example &lt;demo-analytical-nagaitsev&gt;` for detailed usage, and the</span>
<span class="sd">    :ref:`Bjorken-Mtingwa example &lt;demo-analytical-bjorken-mtingwa&gt;` for a comparison to the</span>
<span class="sd">    Bjorken-Mtingwa formalism.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for the calculations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the calculations.</span>
<span class="sd">        elliptic_integrals (NagaitsevIntegrals): the computed elliptic integrals. This</span>
<span class="sd">            self-updates when they are computed with the `integrals` method.</span>
<span class="sd">        ibs_growth_rates (IBSGrowthRates): the computed IBS growth rates. This self-updates</span>
<span class="sd">            when they are computed with the `growth_rates` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span> <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">)</span>
        <span class="c1"># This self-updates when computed, but can be overwritten by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elliptic_integrals</span><span class="p">:</span> <span class="n">NagaitsevIntegrals</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="NagaitsevIBS.integrals">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.NagaitsevIBS.integrals">[docs]</a>
    <span class="k">def</span> <span class="nf">integrals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NagaitsevIntegrals</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">        Computes the Nagaitsev integrals, named :math:`I_x, I_y` and :math:`I_z` in this code base.</span>

<span class="sd">        These correspond to the integrals inside of Eq (32), (31) and (30) in</span>
<span class="sd">        :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`, respectively.</span>
<span class="sd">        The instance attribute `self.elliptic_integrals` is automatically updated</span>
<span class="sd">        with the results of this method. It is used for other calculations.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps, which are related to different</span>
<span class="sd">            equations in :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`:</span>

<span class="sd">                - Computes various intermediate terms and then :math:`a_x, a_y, a_s, a_1` and :math:`a_2` constants from Eq (18-21).</span>
<span class="sd">                - Computes the eigenvalues :math:`\lambda_1, \lambda_2` of the :math:`\bf{A}` matrix (:math:`\bf{L}` matrix in B&amp;M) from Eq (22-24).</span>
<span class="sd">                - Computes the :math:`R_1, R_2` and :math:`R_3` terms from Eq (25-27) with the forms of Eq (5-6).</span>
<span class="sd">                - Computes the :math:`S_p, S_x` and :math:`S_{xp}` terms from Eq (33-35).</span>
<span class="sd">                - Computes and returns the integrals terms in Eq (30-32).</span>

<span class="sd">        .. note::</span>
<span class="sd">            Both geometric or normalized emittances can be given as input to this function, and it is assumed</span>
<span class="sd">            the user provides geomettric emittances. If normalized ones are given the `normalized_emittances`</span>
<span class="sd">            parameter should be set to `True` (it defaults to `False`). Internally, a conversion is done to</span>
<span class="sd">            geometric emittances, which are used in the computations.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread. Defaults to `None`.</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `NagaitsevIntegrals` object with the computed integrals for each plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing Nagaitsev integrals for defined beam and optics parameters&quot;</span><span class="p">)</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># All of the following (when type annotated as np.ndarray), hold one value per element in the lattice</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we are working with geometric emittances</span>
        <span class="n">geom_epsx</span> <span class="o">=</span> <span class="n">epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsx</span><span class="p">)</span>
        <span class="n">geom_epsy</span> <span class="o">=</span> <span class="n">epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing necessary intermediate terms for the following lines</span>
        <span class="n">sigx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">*</span> <span class="n">geom_epsx</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">sigma_delta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sigy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">*</span> <span class="n">geom_epsy</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">sigma_delta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span><span class="p">)</span>
        <span class="c1"># Computing the constants from Eq (18-21) in Nagaitsev paper</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>
        <span class="n">ay</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>
        <span class="n">a_s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">ax</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">a1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a_s</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">a2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a_s</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">sqrt_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ax</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># square root term in Eq (22-23) and Eq (33-35)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># These are from Eq (22-24) in Nagaitsev paper, eigen values of A matrix (L matrix in B&amp;M)</span>
        <span class="n">lambda_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">ay</span>
        <span class="n">lambda_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">sqrt_term</span>
        <span class="n">lambda_3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">sqrt_term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># These are the R_D terms to compute, from Eq (25-27) in Nagaitsev paper (at each element of the lattice)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing elliptic integrals R1, R2 and R3&quot;</span><span class="p">)</span>
        <span class="n">R1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">elliprd</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">lambda_1</span>
        <span class="n">R2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">elliprd</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_2</span><span class="p">)</span> <span class="o">/</span> <span class="n">lambda_2</span>
        <span class="n">R3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_1</span> <span class="o">*</span> <span class="n">lambda_2</span> <span class="o">/</span> <span class="n">lambda_3</span><span class="p">)</span> <span class="o">-</span> <span class="n">lambda_1</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">/</span> <span class="n">lambda_3</span> <span class="o">-</span> <span class="n">lambda_2</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">/</span> <span class="n">lambda_3</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># This are the terms from Eq (33-35) in Nagaitsev paper</span>
        <span class="n">Sp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">-</span> <span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">-</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">Sx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">-</span> <span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">-</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">Sxp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">R3</span> <span class="o">-</span> <span class="n">R2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt_term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># These are the integrands of the integrals in Eq (30-32) in Nagaitsev paper</span>
        <span class="n">Ix_integrand</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigx</span> <span class="o">*</span> <span class="n">sigy</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">Sx</span> <span class="o">+</span> <span class="n">Sp</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sxp</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">Iy_integrand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigx</span> <span class="o">*</span> <span class="n">sigy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">R2</span> <span class="o">+</span> <span class="n">R3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span><span class="p">)</span>
        <span class="n">Iz_integrand</span> <span class="o">=</span> <span class="n">Sp</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigx</span> <span class="o">*</span> <span class="n">sigy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Integrating the integrands above accross the ring to get the desired results</span>
        <span class="c1"># This is identical to np.trapz(Ixyz_integrand, self.optics.s) but faster and somehow closer to MAD-X values</span>
        <span class="n">Ix</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ix_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">)))</span>
        <span class="n">Iy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Iy_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">)))</span>
        <span class="n">Iz</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Iz_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">)))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">NagaitsevIntegrals</span><span class="p">(</span><span class="n">Ix</span><span class="p">,</span> <span class="n">Iy</span><span class="p">,</span> <span class="n">Iz</span><span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Self-update the instance&#39;s attributes and then return the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elliptic_integrals</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="NagaitsevIBS.growth_rates">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.NagaitsevIBS.growth_rates">[docs]</a>
    <span class="k">def</span> <span class="nf">growth_rates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_integrals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSGrowthRates</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">        Computes the ``IBS`` growth rates, named :math:`T_x, T_y` and :math:`T_z` in this</span>
<span class="sd">        code base, from Nagaitsev integrals. These correspond to the :math:`1 / \tau` term,</span>
<span class="sd">        for each plane, of Eq (28) in :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`,</span>
<span class="sd">        respectively. The instance attribute `self.ibs_growth_rates` is automatically updated</span>
<span class="sd">        with the results of this method when it is called.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Currently this calculation does not take into account vertical dispersion. Should you have</span>
<span class="sd">            any in your lattice, please use the BjorkenMtingwaIBS class instead, which supports it fully.</span>
<span class="sd">            Supporting vertical dispersion in NagaitsevIBS might be implemented in a future version.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps, which are related to different</span>
<span class="sd">            equations in :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`:</span>

<span class="sd">                - Get the Nagaitsev integrals from the instance attributes (integrals of Eq (30-32)).</span>
<span class="sd">                - Computes the Coulomb logarithm for the defined beam and optics parameters.</span>
<span class="sd">                - Compute the rest of the constant term of Eq (30-32).</span>
<span class="sd">                - Compute for each plane the full result of Eq (30-32), respectively.</span>
<span class="sd">                - Plug these into Eq (28) and divide by either :math:`\varepsilon_x, \varepsilon_y` or :math:`\sigma_{\delta}^{2}` (as relevant) to get :math:`1 / \tau`.</span>

<span class="sd">            **Note:** As one can see above, this calculation is done by building on the Nagaitsev integrals.</span>
<span class="sd">            If these have not been computed yet, this method will first log a message and compute them, then</span>
<span class="sd">            compute the growth rates.</span>

<span class="sd">        .. admonition:: Geometric or Normalized Emittances</span>

<span class="sd">            Both geometric or normalized emittances can be given as input to this function, and it is assumed</span>
<span class="sd">            the user provides geomettric emittances. If normalized ones are given the `normalized_emittances`</span>
<span class="sd">            parameter should be set to `True` (it defaults to `False`). Internally, a conversion is done to</span>
<span class="sd">            geometric emittances, which are used in the computations. For more information please see the</span>
<span class="sd">            following :ref:`section of the FAQ &lt;xibs-faq-geom-norm-emittances&gt;`.</span>

<span class="sd">        .. admonition:: Coasting Beams</span>

<span class="sd">            It is possible in this formalism to get an approximation in the case of coasting beams by providing</span>
<span class="sd">            `bunched=False`. This will as a bunch length :math:`C / 2 \pi` with C the circumference (or length)</span>
<span class="sd">            of the machine, and a warning will be logged for the user. Additionally the appropriate adjustement</span>
<span class="sd">            will be made in the Coulomb logarithm calculation, and the resulting growth rates will be divided by</span>
<span class="sd">            a factor 2 before being returned (see :cite:`ICHEA:Piwinski:IntraBeamScattering`). For fully accurate</span>
<span class="sd">            results in the case of coasting beams, please use the `BjorkenMtingwaIBS` class instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`. Please note</span>
<span class="sd">                that this will do an approximation using `bunch_length=C/(2*pi)`. For fully accurate results</span>
<span class="sd">                in the case of coasting beams, please use the BjorkenMtingwaIBS class instead.</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>
<span class="sd">            compute_integrals (bool): if `True`, the Nagaitsev elliptic integrals will be computed</span>
<span class="sd">                before the growth rates. Defaults to `True`. New in version 0.3.0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `IBSGrowthRates` object with the computed growth rates for each plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Catch and raise an error if the user asks for coasting beam (not implemented yet)</span>
        <span class="k">if</span> <span class="n">bunched</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Using &#39;bunched=False&#39; in this formalism makes the approximation of bunch length = C/(2*pi). &quot;</span>
                <span class="s2">&quot;Please use the BjorkenMtingwaIBS class for fully accurate results.&quot;</span>
            <span class="p">)</span>
            <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we are working with geometric emittances</span>
        <span class="n">geom_epsx</span> <span class="o">=</span> <span class="n">epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsx</span><span class="p">)</span>
        <span class="n">geom_epsy</span> <span class="o">=</span> <span class="n">epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Check that the Nagaitsev integrals have been computed beforehand</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elliptic_integrals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">compute_integrals</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Computing growth rates requires having computed Nagaitsev integrals. They will be computed first.&quot;</span>
            <span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrals</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the integrals if asked to by the user (default behaviour)</span>
        <span class="k">if</span> <span class="n">compute_integrals</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrals</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing IBS growth rates for defined beam and optics parameters&quot;</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Get the Coulomb logarithm and the rest of the constant term in Eq (30-32)</span>
        <span class="n">coulomb_logarithm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coulomb_log</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">,</span> <span class="n">bunch_length</span><span class="p">,</span> <span class="n">bunched</span><span class="p">)</span>
        <span class="c1"># Then the rest of the constant term in the equation</span>
        <span class="c1"># fmt: off</span>
        <span class="n">rest_of_constant_term</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">n_part</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_classical_radius_m</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c</span> 
            <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="o">**</span><span class="mi">5</span> <span class="o">*</span> <span class="n">bunch_length</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="n">full_constant_term</span> <span class="o">=</span> <span class="n">rest_of_constant_term</span> <span class="o">*</span> <span class="n">coulomb_logarithm</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the full result of Eq (30-32) for each plane | make sure to convert back to float</span>
        <span class="n">Ix</span><span class="p">,</span> <span class="n">Iy</span><span class="p">,</span> <span class="n">Iz</span> <span class="o">=</span> <span class="n">astuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elliptic_integrals</span><span class="p">)</span>
        <span class="c1"># Below: if coasting beams since we use bunch_length=C/(2*pi) we have to divide rates by 2 (see Piwinski)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">bunched</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="mf">2.0</span>
        <span class="n">Tx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ix</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsx</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">Ty</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Iy</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsy</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">Tz</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Iz</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">IBSGrowthRates</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Self-update the instance&#39;s attributes and then return the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>



<div class="viewcode-block" id="BjorkenMtingwaIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.BjorkenMtingwaIBS">[docs]</a>
<span class="k">class</span> <span class="nc">BjorkenMtingwaIBS</span><span class="p">(</span><span class="n">AnalyticalIBS</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.3.0</span>

<span class="sd">    A single class to compute the IBS growth rates according to the `Bjorken &amp; Mtingwa` formalism.</span>
<span class="sd">    The exact approach follows the ``MAD-X`` implementation, which has corrected B&amp;M in order to</span>
<span class="sd">    take in consideration the vertical dispersion values (see the relevant note about the changes</span>
<span class="sd">    at :cite:`CERN:Antoniou:Revision_IBS_MADX`). It initiates from a `BeamParameters` and an</span>
<span class="sd">    `OpticsParameters` objects.</span>

<span class="sd">    See the :ref:`Bjorken-Mtingwa example &lt;demo-analytical-bjorken-mtingwa&gt;` for detailed usage,</span>
<span class="sd">    and the :ref:`Nagaitsev example &lt;demo-analytical-nagaitsev&gt;` for a comparison to the Nagaitsev</span>
<span class="sd">    formalism.</span>

<span class="sd">    .. note::</span>
<span class="sd">        If possible, when creating the `OpticsParameters` to initiate this class, please do so</span>
<span class="sd">        by providing the ``TWISS`` values calculated at the center of elements. This is done by</span>
<span class="sd">        giving the flag `centre=true` to the ``TWISS`` command in ``MAD-X``, for instance. If</span>
<span class="sd">        this isn&#39;t done, a warning will be issued that one might observe some slight discrepancies</span>
<span class="sd">        against ``MAD-X`` result values.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for the calculations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the calculations.</span>
<span class="sd">        ibs_growth_rates (IBSGrowthRates): the computed IBS growth rates. This self-updates</span>
<span class="sd">            when they are computed with the `growth_rates` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span> <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Gamma</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.0</span>

<span class="sd">        Computes :math:`\Gamma`, the 6-dimensional invariant phase space volume of a bunched beam.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric emittance in [m].</span>
<span class="sd">            epxy (float): vertical geometric emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The computed :math:`\Gamma` value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fmt: off</span>
        <span class="k">if</span> <span class="n">bunched</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_mass_eV</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>  <span class="c1"># use mass in MeV like in .growth_rates method (the m^3 terms cancel out)</span>
                <span class="o">*</span> <span class="n">geom_epsx</span>
                <span class="o">*</span> <span class="n">geom_epsy</span>
                <span class="o">*</span> <span class="n">sigma_delta</span>
                <span class="o">*</span> <span class="n">bunch_length</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># we have coasting beam</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
                <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_mass_eV</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>  <span class="c1"># use mass in MeV like in .growth_rates method (the m^3 terms cancel out)</span>
                <span class="o">*</span> <span class="n">geom_epsx</span>
                <span class="o">*</span> <span class="n">geom_epsy</span>
                <span class="o">*</span> <span class="n">sigma_delta</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
            <span class="p">)</span>
        <span class="c1"># fmt: on</span>

    <span class="k">def</span> <span class="nf">_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the a term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span> <span class="o">+</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">_b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the b term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betxbety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># beta_x * beta_y term</span>
        <span class="n">epsxepsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">geom_epsx</span> <span class="o">*</span> <span class="n">geom_epsy</span>  <span class="c1"># eps_x * eps_y term</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">geom_epsx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">geom_epsy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="n">betxbety</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">epsxepsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betxbety</span> <span class="o">/</span> <span class="n">epsxepsy</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the c term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betxbety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># beta_x * beta_y term</span>
        <span class="n">epsxepsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">geom_epsx</span> <span class="o">*</span> <span class="n">geom_epsy</span>  <span class="c1"># eps_x * eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">betxbety</span> <span class="o">/</span> <span class="p">(</span><span class="n">epsxepsy</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">geom_epsx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">geom_epsy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">_ax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the ax term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We define new shorter names for a lot of arrays, for clarity of the expressions below</span>
        <span class="n">betx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>  <span class="c1"># horizontal beta-functions</span>
        <span class="n">bety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># vertical beta-functions</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsx</span>  <span class="c1"># horizontal geometric emittance</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsy</span>  <span class="c1"># vertical geometric emittance</span>
        <span class="n">sigd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_delta</span>  <span class="c1"># momentum spread</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">betx</span> <span class="o">/</span> <span class="n">epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">/</span> <span class="n">epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># double checked formula vs table - not same values as tx1 * cprime!</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">epsx</span> <span class="o">+</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">epsy</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">betx</span> <span class="o">*</span> <span class="n">Hy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">*</span> <span class="n">epsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betx</span> <span class="o">/</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span> <span class="o">-</span> <span class="n">bety_over_epsy</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span>
            <span class="o">-</span> <span class="n">bety_over_epsy</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betx</span> <span class="o">/</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_bx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the bx term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We define new shorter names for a lot of arrays, for clarity of the expressions below</span>
        <span class="n">betx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>  <span class="c1"># horizontal beta-functions</span>
        <span class="n">bety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># vertical beta-functions</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsx</span>  <span class="c1"># horizontal geometric emittance</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsy</span>  <span class="c1"># vertical geometric emittance</span>
        <span class="n">sigd</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_delta</span>  <span class="c1"># momentum spread</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">betx</span> <span class="o">/</span> <span class="n">epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">/</span> <span class="n">epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">bx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># double checked formula vs table - not same values as tx2 * cprime</span>
            <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Hx</span> <span class="o">/</span> <span class="n">epsx</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">epsy</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betx</span> <span class="o">/</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigd</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="n">bety_over_epsy</span>
                <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="n">bety_over_epsy</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span>
                <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bety_over_epsy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">betx_over_epsx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="p">((</span><span class="n">betx</span> <span class="o">*</span> <span class="n">Hy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">epsy</span> <span class="o">*</span> <span class="n">Hx</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bx</span>

    <span class="k">def</span> <span class="nf">_ay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the ay term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">ay</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="p">(</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span>
                <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span>
                <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">*</span> <span class="n">Hy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">*</span> <span class="n">geom_epsx</span><span class="p">)</span>
                <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">*</span> <span class="p">(</span><span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span> <span class="o">+</span> <span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">*</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">bety_over_epsy</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ay</span>

    <span class="k">def</span> <span class="nf">_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the by term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betxbety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># beta_x * beta_y term</span>
        <span class="n">epsxepsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">geom_epsx</span> <span class="o">*</span> <span class="n">geom_epsy</span>  <span class="c1"># eps_x * eps_y term</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bety_over_epsy</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span> <span class="o">*</span> <span class="p">(</span><span class="n">bety_over_epsy</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">betx_over_epsx</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">betxbety</span> <span class="o">/</span> <span class="n">epsxepsy</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bety_over_epsy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">4</span>
            <span class="o">*</span> <span class="n">Hy</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Hx</span> <span class="o">*</span> <span class="n">Hy</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">*</span> <span class="n">geom_epsx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">4</span>
            <span class="o">*</span> <span class="n">Hy</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="n">bety_over_epsy</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">by</span>

    <span class="k">def</span> <span class="nf">_az</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the al term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">az</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span> <span class="o">+</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">betx_over_epsx</span>
            <span class="o">-</span> <span class="n">bety_over_epsy</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">az</span>

    <span class="k">def</span> <span class="nf">_bz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the bl term of Table 1 in the MAD-X note.&quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">betx_over_epsx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>  <span class="c1"># beta_x / eps_x term</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpy</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">phiy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dpy</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>
        <span class="n">Hy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="n">bz</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">betx_over_epsx</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">geom_epsx</span> <span class="o">+</span> <span class="n">Hy</span> <span class="o">/</span> <span class="n">geom_epsy</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">betx_over_epsx</span> <span class="o">*</span> <span class="n">bety_over_epsy</span>
            <span class="o">-</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">betx_over_epsx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bety_over_epsy</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phiy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bz</span>

    <span class="k">def</span> <span class="nf">_constants</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.0</span>

<span class="sd">        Computes the constant terms of Eq (8) in :cite:`CERN:Antoniou:Revision_IBS_MADX`.</span>
<span class="sd">        Returned are four terms: first the constant common to all planes, then the horizontal,</span>
<span class="sd">        vertical and longitudinal terms (in brackets in Eq (8)).</span>

<span class="sd">        The common constant and the longitudinal constant are floats. The horizontal and vertical</span>
<span class="sd">        terms are arrays, with one value per element in the lattice (as they depend on :math:`H_x`</span>
<span class="sd">        and :math:`\beta_y`, respectively).</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric emittance in [m].</span>
<span class="sd">            epxy (float): vertical geometric emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Four variables corresponding to the common, horizontal, vertical and longitudinal</span>
<span class="sd">            constants of Eq (8) in :cite:`CERN:Antoniou:Revision_IBS_MADX`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># We define new shorter names for a lot of arrays, for clarity of the expressions below</span>
        <span class="n">betx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span>  <span class="c1"># horizontal beta-functions</span>
        <span class="n">bety</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span>  <span class="c1"># vertical beta-functions</span>
        <span class="n">alfx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span>  <span class="c1"># horizontal alpha-functions</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsx</span>  <span class="c1"># horizontal geometric emittance</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">geom_epsy</span>  <span class="c1"># vertical geometric emittance</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We compute (once) some convenience terms used a lot in the equations, for efficiency &amp; clarity</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>  <span class="c1"># relativistic beta</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>  <span class="c1"># relativistic gamma</span>
        <span class="n">bety_over_epsy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">/</span> <span class="n">epsy</span>  <span class="c1"># beta_y / eps_y term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Adjust dispersion and dispersion prime by multiplied by relativistic beta, in order to be in the</span>
        <span class="c1"># deltap and not the pt frame (default in MAD-X / xsuite). Necessary for non-relativistic beams</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adjusting Dx, Dy, Dpx, Dpy to be in the pt frame&quot;</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="n">Dpx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing Phi_{x,y} amd H_{x,y} as defined in Eq (6) and Eq (7) of the note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing Phi_x, Phi_y, H_x and H_y at all elements&quot;</span><span class="p">)</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="n">betx</span><span class="p">,</span> <span class="n">alfx</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dpx</span><span class="p">)</span>
        <span class="n">Hx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">betx</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the Coulomb logarithm and the common constant term in Eq (8) (the first fraction)</span>
        <span class="n">coulomb_logarithm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coulomb_log</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">,</span> <span class="n">bunch_length</span><span class="p">,</span> <span class="n">bunched</span><span class="p">)</span>
        <span class="n">common_constant_term</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_classical_radius_m</span><span class="o">**</span><span class="mi">2</span>
            <span class="o">*</span> <span class="n">c</span>
            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_mass_eV</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">**</span> <span class="mi">3</span>  <span class="c1"># use mass in MeV like in ._Gamma method (the m^3 terms cancel out)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">n_part</span>
            <span class="o">*</span> <span class="n">coulomb_logarithm</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Gamma</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">,</span> <span class="n">bunch_length</span><span class="p">,</span> <span class="n">bunched</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># fmt: on</span>
        <span class="c1"># Compute the plane-dependent constants (in brackets) for each plane of Eq (8) in the MAD-X note</span>
        <span class="n">const_x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Hx</span> <span class="o">/</span> <span class="n">epsx</span>
        <span class="n">const_y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bety_over_epsy</span>
        <span class="n">const_z</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Return the four terms now</span>
        <span class="k">return</span> <span class="n">common_constant_term</span><span class="p">,</span> <span class="n">const_x</span><span class="p">,</span> <span class="n">const_y</span><span class="p">,</span> <span class="n">const_z</span>

<div class="viewcode-block" id="BjorkenMtingwaIBS.growth_rates">
<a class="viewcode-back" href="../../modules/index.html#xibs.analytical.BjorkenMtingwaIBS.growth_rates">[docs]</a>
    <span class="k">def</span> <span class="nf">growth_rates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">normalized_emittances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">integration_intervals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSGrowthRates</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.0</span>

<span class="sd">        Computes the ``IBS`` growth rates, named :math:`T_x, T_y` and :math:`T_z` in this code</span>
<span class="sd">        base. These correspond to the :math:`1 / \tau` term, for each plane :math:`x, y` and</span>
<span class="sd">        :math:`z`, respectively. The instance attribute `self.ibs_growth_rates` is automatically</span>
<span class="sd">        updated with the results of this method when it is called.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            When creating the `OpticsParameters` to initiate this class, please do so by providing</span>
<span class="sd">            the ``TWISS`` values calculated at the center of elements. This is done by giving the</span>
<span class="sd">            flag `centre=true` to the ``TWISS`` command in ``MAD-X`` for instance. If not, one might</span>
<span class="sd">            observe some slight discrepancies with the ``MAD-X`` values.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps, which are related to different</span>
<span class="sd">            equations in :cite:`CERN:Antoniou:Revision_IBS_MADX`:</span>

<span class="sd">                - Adjusts the :math:`D_x, D_y, D^{\prime}_{x}, D^{\prime}_{y}` terms (multiply by :math:`\beta_{rel}`) to be in the :math:`pt` frame.</span>
<span class="sd">                - Computes the various terms from Table 1 of the MAD-X note.</span>
<span class="sd">                - Computes the Coulomb logarithm and the common constant term (first fraction) of Eq (8).</span>
<span class="sd">                - Defines the integrands of integrals in Eq (8) of the MAD-X note.</span>
<span class="sd">                - Defines sub-intervals and integrates the above over all of them, getting growth rates at each element in the lattice.</span>
<span class="sd">                - Averages the results over the full circumference of the machine.</span>

<span class="sd">        .. admonition:: Geometric or Normalized Emittances</span>

<span class="sd">            Both geometric or normalized emittances can be given as input to this function, and it is assumed</span>
<span class="sd">            the user provides geomettric emittances. If normalized ones are given the `normalized_emittances`</span>
<span class="sd">            parameter should be set to `True` (it defaults to `False`). Internally, a conversion is done to</span>
<span class="sd">            geometric emittances, which are used in the computations. For more information please see the</span>
<span class="sd">            following :ref:`section of the FAQ &lt;xibs-faq-geom-norm-emittances&gt;`.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsx (float): horizontal geometric or normalized emittance in [m].</span>
<span class="sd">            epsy (float): vertical geometric or normalized emittance in [m].</span>
<span class="sd">            sigma_delta (float): momentum spread.</span>
<span class="sd">            bunch_length (float): the bunch length in [m].</span>
<span class="sd">            bunched (bool): whether the beam is bunched or not (coasting). Defaults to `True`.</span>
<span class="sd">            normalized_emittances (bool): whether the provided emittances are</span>
<span class="sd">                normalized or not. Defaults to `False` (assume geometric emittances).</span>
<span class="sd">            integration_intervals (int): the number of sub-intervals to use when integrating the</span>
<span class="sd">                integrands of Eq (8) of the MAD-X note. Please DO NOT change this parameter unless</span>
<span class="sd">                you know exactly what you are doing, as you might affect convergence. Defaults to 17.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `IBSGrowthRates` object with the computed growth rates for each plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Make sure we are working with geometric emittances</span>
        <span class="n">geom_epsx</span> <span class="o">=</span> <span class="n">epsx</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsx</span><span class="p">)</span>
        <span class="n">geom_epsy</span> <span class="o">=</span> <span class="n">epsy</span> <span class="k">if</span> <span class="n">normalized_emittances</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_emittance</span><span class="p">(</span><span class="n">epsy</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># We warn the user in case the TWISS was not centered - but keep going</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">_is_centered</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Twiss was not calculated at center of elements&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The provided Twiss was calculated at the exit of the elements, but a centered version is &quot;</span>
                <span class="s2">&quot;desired. You might notice some discrepancies with the results from MAD-X itself.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># All of the following (when type annotated as np.ndarray), hold one value per element in the lattice</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Getting the arrays from Table 1 of the MAD-X note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing terms from Table 1 of the MAD-X note&quot;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>    <span class="c1"># This is &#39;a&#39; in MAD-X fortran code</span>
        <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>    <span class="c1"># This is &#39;b&#39; in MAD-X fortran code</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>    <span class="c1"># This is &#39;cprime&#39; in MAD-X fortran code</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;tx1 * cprime / bracket_x&#39; in MAD-X fortran code</span>
        <span class="n">bx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bx</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;tx2 * cprime / bracket_x&#39; in MAD-X fortran code</span>
        <span class="n">ay</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ay</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;ty1 * cprime&#39; in MAD-X fortran code</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_by</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;ty2 * cprime&#39; in MAD-X fortran code</span>
        <span class="n">az</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;tl1 * cprime&#39; in MAD-X fortran code</span>
        <span class="n">bz</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">)</span>  <span class="c1"># This is &#39;tl2 * cprime&#39; in MAD-X fortran code                                   </span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Getting the constant term and the bracket terms from Eq (8) of the MAD-X note</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing common constant term and bracket terms from Eq (8) of the MAD-X note&quot;</span><span class="p">)</span>
        <span class="n">common_constant_term</span><span class="p">,</span> <span class="n">bracket_x</span><span class="p">,</span> <span class="n">bracket_y</span><span class="p">,</span> <span class="n">bracket_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constants</span><span class="p">(</span>
            <span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">,</span> <span class="n">bunch_length</span><span class="p">,</span> <span class="n">bunched</span>
        <span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Defining the integrands from Eq (8) of the MAD-X note, for each plane (remember these functions</span>
        <span class="c1"># are vectorised since a, b, c, ax, bx, ay, by are all arrays). The bracket terms are included.</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Defining integrands of Eq (8) of the MAD-X note&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">Ix_integrand_vec</span><span class="p">(</span><span class="n">_lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
            <span class="n">numerator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bracket_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ax</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">bx</span><span class="p">)</span>
            <span class="n">denominator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">_lambda</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">_lambda</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

        <span class="k">def</span> <span class="nf">Iy_integrand_vec</span><span class="p">(</span><span class="n">_lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
            <span class="n">numerator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bracket_y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ay</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">by</span><span class="p">)</span>
            <span class="n">denominator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">_lambda</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">_lambda</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

        <span class="k">def</span> <span class="nf">Iz_integrand_vec</span><span class="p">(</span><span class="n">_lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
            <span class="n">numerator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">bracket_z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">az</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">bz</span><span class="p">)</span>
            <span class="n">denominator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">_lambda</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">_lambda</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">_lambda</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Defining a function to perform the integrating, which is done sub-interval by sub-interval</span>
        <span class="k">def</span> <span class="nf">calculate_integral_vec</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Defines limits of intervals, then goes over all intervals and performs the integration</span>
<span class="sd">            of the provided function on each one. At each step, we add the intermediate values to the</span>
<span class="sd">            final result, which is returned.&quot;&quot;&quot;</span>
            <span class="n">nb_elements</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">size</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_elements</span><span class="p">)</span>

            <span class="c1"># The following two hold the values for starts and ends of sub-intervals on which to integrate</span>
            <span class="n">interval_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">integration_intervals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="n">interval_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">integration_intervals</span><span class="p">))])</span>

            <span class="c1"># Now we loop over the intervals and integrate the function on each one, using scipy</span>
            <span class="c1"># We add the intermediate integration result of each interval to our final result</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">interval_starts</span><span class="p">,</span> <span class="n">interval_ends</span><span class="p">):</span>
                <span class="n">integrals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad_vec</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>  <span class="c1"># integrals is an array</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">integrals</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># fmt: on</span>
        <span class="c1"># Now we loop over the lattice and compute the integrals at each element</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing integrals of Eq (8) of the MAD-X note - at each element in the lattice&quot;</span><span class="p">)</span>
        <span class="n">Tx_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">calculate_integral_vec</span><span class="p">(</span><span class="n">Ix_integrand_vec</span><span class="p">)</span>
        <span class="n">Ty_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">calculate_integral_vec</span><span class="p">(</span><span class="n">Iy_integrand_vec</span><span class="p">)</span>
        <span class="n">Tz_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">calculate_integral_vec</span><span class="p">(</span><span class="n">Iz_integrand_vec</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Don&#39;t forget to multiply by the common constant term here</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Including common constant term of Eq (8) of the MAD-X note&quot;</span><span class="p">)</span>
        <span class="n">Tx_array</span> <span class="o">*=</span> <span class="n">common_constant_term</span>
        <span class="n">Ty_array</span> <span class="o">*=</span> <span class="n">common_constant_term</span>
        <span class="n">Tz_array</span> <span class="o">*=</span> <span class="n">common_constant_term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the final growth rates for each plane as an average | make sure to convert back to float</span>
        <span class="c1"># Interpolate the growth rates through the lattice for the average calculation below</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Interpolating intermediate growth rates through the lattice&quot;</span><span class="p">)</span>
        <span class="n">_tx</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Tx_array</span><span class="p">)</span>
        <span class="n">_ty</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Ty_array</span><span class="p">)</span>
        <span class="n">_tz</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Tz_array</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># To get a better average, we interpolate the array over the s coordinate, and then integrate this</span>
        <span class="c1"># interpolated function over the whole ring.</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting average growth rates over the lattice&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>  <span class="c1"># Catch and ignore the scipy.integrate.IntegrationWarning</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
            <span class="n">Tx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="n">_tx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span><span class="p">)</span>
            <span class="n">Ty</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="n">_ty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span><span class="p">)</span>
            <span class="n">Tz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="n">_tz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">IBSGrowthRates</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Self-update the instance&#39;s attributes and then return the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibs_growth_rates</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Soubelet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>