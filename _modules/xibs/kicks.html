<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>xibs.kicks &mdash; xibs 0.8.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-codeautolink.css?v=125d5c1c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-dropdown.css?v=995e94df" />
      <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.min.css?v=21c0b90a" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=0a86e678" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=486e5634"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
          </a>
              <div class="version">
                0.8.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#integration-with-xsuite">Integration with xsuite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#formalism-and-models">Formalism and Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#analytical-calculations">Analytical Calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#providing-kicks-to-particle-distributions">Providing Kicks to Particle Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../quickstart.html#formalism-dispatch">Formalism Dispatch</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html">Automatic Growth Rates Re-Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html#instantiate-analytical-ibs-objects">Instantiate Analytical IBS Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html#preparing-for-simulation-of-evolution">Preparing for Simulation of Evolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html#analytical-evolution-over-time">Analytical Evolution Over Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_auto_recompute_rates.html#takeaways">Takeaways</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html">Automatic Kick Coefficients Re-Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html#generating-the-ibs-kick-class">Generating the IBS Kick Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html#computing-and-applying-ibs-kicks">Computing and Applying IBS Kicks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html#preparing-for-the-tracking-simulation">Preparing for the Tracking Simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kicks_auto_recompute_coefficients.html#tracking-evolution-over-turns">Tracking Evolution Over Turns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html">Bjorken-Mtingwa Formalism - Analytical Growth Rates and Emittance Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#computing-ibs-growth-rates">Computing IBS Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#computing-new-emittances-from-growth-rates">Computing New Emittances from Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_bjorken_mtingwa_emittances.html#analytical-evolution-for-a-time-period">Analytical Evolution for a Time Period</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_compare_analyticals.html">Comparison of Analytical IBS Growth Rates and Emittances Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_compare_analyticals.html#comparing-analytical-evolution-for-a-time-period">Comparing Analytical Evolution for a Time Period</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_compare_kicks.html">Comparison of IBS Kicks Formalisms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_compare_kicks.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_compare_kicks.html#generating-the-ibs-kick-classes">Generating the IBS Kick Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_compare_kicks.html#comparing-beam-parameters-evolution-while-applying-ibs-kicks-in-tracking">Comparing Beam Parameters Evolution While Applying IBS Kicks in Tracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_kinetic_kicks.html">Kinetic Kicks Formalism - IBS Kicks Based on Diffusion and Friction Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kinetic_kicks.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kinetic_kicks.html#generating-the-ibs-kick-class">Generating the IBS Kick Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kinetic_kicks.html#computing-and-applying-ibs-kicks">Computing and Applying IBS Kicks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_kinetic_kicks.html#applying-ibs-kicks-in-tracking">Applying IBS Kicks in Tracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html">Nagaitsev Formalism - Analytical Growth Rates and Emittance Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#computing-elliptic-integrals-and-ibs-growth-rates">Computing Elliptic Integrals and IBS Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#computing-new-emittances-from-growth-rates">Computing New Emittances from Growth Rates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_analytical_nagaitsev_emittances.html#analytical-evolution-for-many-turns">Analytical Evolution for Many Turns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery/demo_simple_kicks.html">Simple Kicks Formalism - IBS Kicks Based on Analytical Growth Rates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#setting-up-line-and-particles">Setting up line and particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#generating-the-ibs-kick-class">Generating the IBS Kick Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#computing-and-applying-ibs-kicks">Computing and Applying IBS Kicks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gallery/demo_simple_kicks.html#applying-ibs-kicks-in-tracking">Applying IBS Kicks in Tracking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#input-data-structures">Input Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#formalism-dispatch">Formalism Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#ibs-analytical-calculations">IBS: Analytical Calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#ibs-applying-kicks">IBS: Applying Kicks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/index.html#formulary">Formulary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/index.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../faq/input_parameters.html">Instantiating Input Parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#opticsparameters-from-an-xtrack-line">OpticsParameters from an <code class="xref py py-obj docutils literal notranslate"><span class="pre">xtrack.Line</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#opticsparameters-from-mad-x">OpticsParameters from <code class="docutils literal notranslate"><span class="pre">MAD-X</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#do-i-need-a-full-matched-particle-distribution-for-beamparameters">Do I need a full matched particle distribution for <code class="xref py py-obj docutils literal notranslate"><span class="pre">BeamParameters</span></code>?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#beamparameters-from-an-xtrack-line">BeamParameters from an <code class="xref py py-obj docutils literal notranslate"><span class="pre">xtrack.Line</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/input_parameters.html#beamparameters-from-mad-x">BeamParameters from <code class="docutils literal notranslate"><span class="pre">MAD-X</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/emittance_types.html">Emittances: Geometric or Normalized</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/radiation.html">Synchrotron Radiation Contribution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faq/radiation.html#getting-sr-parameters-from-xsuite">Getting SR Parameters from Xsuite</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/radiation.html#getting-sr-parameters-from-mad-x">Getting SR Parameters from MAD-X</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/coasting_beams.html">Bunched and Coasting Beams</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faq/auto_recomputing.html">Automatic Recomputation of IBS Kick Coefficients and Growth Rates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faq/auto_recomputing.html#auto-recomputing-for-ibs-kick-classes">Auto-Recomputing for IBS Kick Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../faq/auto_recomputing.html#auto-recomputing-for-ibs-analytical-classes">Auto-Recomputing for IBS Analytical Classes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Reference Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">xibs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">xibs.kicks</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for xibs.kicks</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. _xibs-kicks:</span>

<span class="sd">IBS: Applying Kicks</span>
<span class="sd">-------------------</span>

<span class="sd">Module with user-facing API to compute relevant terms to IBS kicks according to different formalism: simple and kinetic kicks.</span>

<span class="sd">In the simple formalism, the applied IBS kicks are determined from analytical IBS growth rates, which are computed internally (see :ref:`xibs-analytical`).</span>
<span class="sd">In the kinetic formalism, which adapts the kinetic theory of gases, the applied IBS kicks are determined from computed diffusion and friction terms.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>  <span class="c1"># important for sphinx to alias ArrayLike</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">astuple</span><span class="p">,</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">c</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">elliprd</span>

<span class="kn">from</span> <span class="nn">xibs.analytical</span> <span class="kn">import</span> <span class="n">AnalyticalIBS</span><span class="p">,</span> <span class="n">BjorkenMtingwaIBS</span><span class="p">,</span> <span class="n">IBSGrowthRates</span><span class="p">,</span> <span class="n">NagaitsevIBS</span>
<span class="kn">from</span> <span class="nn">xibs.formulary</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_bunch_length</span><span class="p">,</span>
    <span class="n">_geom_epsx</span><span class="p">,</span>
    <span class="n">_geom_epsy</span><span class="p">,</span>
    <span class="n">_percent_change</span><span class="p">,</span>
    <span class="n">_sigma_delta</span><span class="p">,</span>
    <span class="n">_sigma_x</span><span class="p">,</span>
    <span class="n">_sigma_y</span><span class="p">,</span>
    <span class="n">phi</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">xibs.inputs</span> <span class="kn">import</span> <span class="n">BeamParameters</span><span class="p">,</span> <span class="n">OpticsParameters</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># ----- Dataclasses to store results ----- #</span>


<div class="viewcode-block" id="DiffusionCoefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.DiffusionCoefficients">[docs]</a>
<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">DiffusionCoefficients</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container dataclass for kinetic IBS diffusion coefficients.</span>

<span class="sd">    Args:</span>
<span class="sd">        Dx (float): horizontal diffusion coefficient.</span>
<span class="sd">        Dy (float): vertical diffusion coefficient.</span>
<span class="sd">        Dz (float): longitudinal diffusion coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Dx</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Dy</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Dz</span><span class="p">:</span> <span class="nb">float</span></div>



<div class="viewcode-block" id="FrictionCoefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.FrictionCoefficients">[docs]</a>
<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">FrictionCoefficients</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container dataclass for kinetic IBS friction coefficients.</span>

<span class="sd">    Args:</span>
<span class="sd">        Fx (float): horizontal friction coefficient.</span>
<span class="sd">        Fy (float): vertical friction coefficient.</span>
<span class="sd">        Fz (float): longitudinal friction coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Fx</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Fy</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Fz</span><span class="p">:</span> <span class="nb">float</span></div>



<div class="viewcode-block" id="IBSKickCoefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.IBSKickCoefficients">[docs]</a>
<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">IBSKickCoefficients</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container dataclass for all IBS kick coefficients. These can be the coeffients from simple kicks,</span>
<span class="sd">    computed from analytical growth rates, or kinetic coefficients computed from the diffusion and</span>
<span class="sd">    friction ones according to :cite:`NuclInstr:Zenkevich:Kinetic_IBS`.</span>

<span class="sd">    Args:</span>
<span class="sd">        Kx (float): horizontal kick coefficient.</span>
<span class="sd">        Ky (float): vertical kick coefficient.</span>
<span class="sd">        Kz (float): longitudinal kick coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Kx</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Ky</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Kz</span><span class="p">:</span> <span class="nb">float</span></div>



<span class="c1"># ----- Abstract Base Class to Inherit from ----- #</span>


<div class="viewcode-block" id="KickBasedIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KickBasedIBS">[docs]</a>
<span class="k">class</span> <span class="nc">KickBasedIBS</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.5.0</span>

<span class="sd">    Abstract base class for kick-based IBS effects, from which all</span>
<span class="sd">    implementations inherit.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for IBS computations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the IBS computations.</span>
<span class="sd">        auto_recompute_coefficients_percent (float): Optional. If given, a check is performed after</span>
<span class="sd">            kicking the particles to determine if recomputing the kick coefficients is necessary, in</span>
<span class="sd">            which case it will be done before the next kick. **Please provide a value as a percentage</span>
<span class="sd">            of the emittance change**. For instance, if one provides `12` after kicking a check is</span>
<span class="sd">            done to see if the emittance changed by more than 12% in any plane, and if so the coefficients</span>
<span class="sd">            will be automatically recomputed before the next kick. Defaults to `None` (no checks done,</span>
<span class="sd">            no auto-recomputing).</span>
<span class="sd">        kick_coefficients (IBSKickCoefficients): the computed IBS kick coefficients. This</span>
<span class="sd">            attribute self-updates when they are computed with the `compute_kick_coefficients`</span>
<span class="sd">            method. It can also be set manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span>
        <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">,</span>
        <span class="n">auto_recompute_coefficients_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="p">:</span> <span class="n">BeamParameters</span> <span class="o">=</span> <span class="n">beam_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span> <span class="o">=</span> <span class="n">optics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_recompute_coefficients_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">auto_recompute_coefficients_percent</span>
        <span class="c1"># These coefficients self-update when computed, but can be overwritten by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="p">:</span> <span class="n">IBSKickCoefficients</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Private flag to indicate if the coefficients need to be recomputed before the next kick</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Private attribute tracking the number of coefficients computations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_coefficients_computations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">has_kick_coefficients</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="p">,</span> <span class="n">IBSKickCoefficients</span><span class="p">)</span>
        <span class="n">auto_recomputes_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_recompute_coefficients_percent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object for kick-based IBS calculations. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;IBS kick coefficients computed: </span><span class="si">{</span><span class="n">has_kick_coefficients</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Auto-recompute coefficients: </span><span class="si">{</span><span class="n">auto_recomputes_coefficients</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="KickBasedIBS.line_density">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KickBasedIBS.line_density">[docs]</a>
    <span class="k">def</span> <span class="nf">line_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Returns the &quot;line density&quot; of the `Particles` object, along its longitudinal axis, which</span>
<span class="sd">        corresponds to the :math:`\rho_t(t)` term in Eq (8) of :cite:`PRAB:Bruce:Simple_IBS_Kicks`.</span>
<span class="sd">        The density is used as a weight factor for the application of IBS kicks: particles in the</span>
<span class="sd">        denser parts of the bunch will receive a larger kick, and vice versa. See section III.C of</span>
<span class="sd">        the above reference details.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps:</span>

<span class="sd">                - Gets the longitudinal coordinates of the active particles (state &gt; 0) in the `Particles` object.</span>
<span class="sd">                - Determines coordinate cuts at front and back of the bunch, as well as slice width.</span>
<span class="sd">                - Determines bin edges and bin centers for the distribution for the chosen number of slices.</span>
<span class="sd">                - Computes a (normalized) histogram of the longitudinal coordinates, with the determined bins.</span>
<span class="sd">                - Computes and returns the line density :math:`\rho_t(t)`.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the `xtrack.Particles` object to compute the line density for.</span>
<span class="sd">            n_slices (int): the number of slices to use for the computation of the bins.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An array with the density values for each slice / bin of the `Particles` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Start with getting the nplike_lib from the particles&#39; context, to compute on the context device</span>
        <span class="n">nplike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">nplike_lib</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determine properties from longitudinal particles distribution: cuts, slice width, bunch length</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining longitudinal particles distribution properties&quot;</span><span class="p">)</span>
        <span class="n">zeta</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">zeta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># careful to only consider active particles</span>
        <span class="n">z_cut_head</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>  <span class="c1"># z cut at front of bunch</span>
        <span class="n">z_cut_tail</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>  <span class="c1"># z cut at back of bunch</span>
        <span class="n">slice_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_cut_head</span> <span class="o">-</span> <span class="n">z_cut_tail</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_slices</span>  <span class="c1"># slice width</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determine bin edges and bin centers for the distribution</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining bin edges and bin centers for the distribution&quot;</span><span class="p">)</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">z_cut_tail</span> <span class="o">-</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">slice_width</span><span class="p">,</span>
            <span class="n">z_cut_head</span> <span class="o">+</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">slice_width</span><span class="p">,</span>
            <span class="n">num</span><span class="o">=</span><span class="n">n_slices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute histogram on longitudinal distribution then compute and return line density</span>
        <span class="n">counts_normed</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># density to normalize</span>
        <span class="k">return</span> <span class="n">nplike</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="n">bin_centers</span><span class="p">,</span> <span class="n">counts_normed</span><span class="p">)</span></div>


<div class="viewcode-block" id="KickBasedIBS.compute_kick_coefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KickBasedIBS.compute_kick_coefficients">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute_kick_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSKickCoefficients</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Abstract method to determine the kick coefficients used in the determination of the IBS</span>
<span class="sd">        to be applied. It returns an `IBSKickCoefficients` object with the computed coefficients.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the particles to apply the IBS kicks to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_check_coefficients_presence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Abstract method to check the relevant attribute and determine if the</span>
<span class="sd">        kick coefficients have been computed. This is called before applying kicks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_apply_formalism_ibs_kick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Abstract method to determine and apply IBS kicks to a `xtrack.Particles` object. The</span>
<span class="sd">        implementation details vary depending on the formalism implemented. This method is</span>
<span class="sd">        called in the `apply_ibs_kick` method.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the particles to apply the IBS kicks to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="KickBasedIBS.apply_ibs_kick">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KickBasedIBS.apply_ibs_kick">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_ibs_kick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Compute and apply momenta kicks based on the provided `xtrack.Particles` object and the</span>
<span class="sd">        chosen ``IBS`` formalism. See the `_apply_formalism_ibs_kick` method for implementation details</span>
<span class="sd">        of the currently selected formalism.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the `xtrack.Particles` object to apply ``IBS`` kicks to.</span>
<span class="sd">            n_slices (int): the number of slices to use for the computation of the line density.</span>
<span class="sd">                Defaults to 40.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Check that the kick coefficients have been computed beforehand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_coefficients_presence</span><span class="p">()</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Check the auto-recompute flag and recompute coefficients if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Recomputing IBS kick coefficients before applying kicks&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_kick_coefficients</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Get and store pre-kick emittances if self.auto_recompute_coefficients_percent is set</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_recompute_coefficients_percent</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">_previous_bunch_length</span> <span class="o">=</span> <span class="n">_bunch_length</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
            <span class="n">_previous_sigma_delta</span> <span class="o">=</span> <span class="n">_sigma_delta</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
            <span class="c1"># below we give index 0 as start / end of machine is kick location</span>
            <span class="n">_previous_geom_epsx</span> <span class="o">=</span> <span class="n">_geom_epsx</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">_previous_geom_epsy</span> <span class="o">=</span> <span class="n">_geom_epsy</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Apply the kicks to the particles - the function implementation here is formalism-specific</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_formalism_ibs_kick</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Get post-kick emittances, check growth and set recompute flag if necessary (only if self.auto_recompute_coefficients_percent is set)</span>
        <span class="c1"># fmt: off</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_recompute_coefficients_percent</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">_new_bunch_length</span> <span class="o">=</span> <span class="n">_bunch_length</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
            <span class="n">_new_sigma_delta</span> <span class="o">=</span> <span class="n">_sigma_delta</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
            <span class="n">_new_geom_epsx</span> <span class="o">=</span> <span class="n">_geom_epsx</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">_new_geom_epsy</span> <span class="o">=</span> <span class="n">_geom_epsy</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># If there is an increase / decrease of more than self.auto_recompute_coefficients_percent % in any plane, set the flag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_threshold_bypass</span><span class="p">(</span>
                <span class="n">_previous_geom_epsx</span><span class="p">,</span> <span class="n">_previous_geom_epsy</span><span class="p">,</span> <span class="n">_previous_sigma_delta</span><span class="p">,</span> <span class="n">_previous_bunch_length</span><span class="p">,</span>
                <span class="n">_new_geom_epsx</span><span class="p">,</span> <span class="n">_new_geom_epsy</span><span class="p">,</span> <span class="n">_new_sigma_delta</span><span class="p">,</span> <span class="n">_new_bunch_length</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">auto_recompute_coefficients_percent</span>
            <span class="p">)</span></div>

        <span class="c1"># fmt: on</span>

    <span class="k">def</span> <span class="nf">_check_threshold_bypass</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">new_epsx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">new_epsy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">new_sigma_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">new_bunch_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if any of the quantities exceed a &#39;threshold&#39;% relative change to the initial</span>
<span class="sd">        ones and if so, set the `self._need_to_recompute_coefficients` flag to `True`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>  <span class="c1"># REMEMBER: threshold is a percentage so we need to divide it by 100</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">_percent_change</span><span class="p">(</span><span class="n">epsx</span><span class="p">,</span> <span class="n">new_epsx</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_percent_change</span><span class="p">(</span><span class="n">epsy</span><span class="p">,</span> <span class="n">new_epsy</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_percent_change</span><span class="p">(</span><span class="n">sigma_delta</span><span class="p">,</span> <span class="n">new_sigma_delta</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_percent_change</span><span class="p">(</span><span class="n">bunch_length</span><span class="p">,</span> <span class="n">new_bunch_length</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mi">100</span>
        <span class="p">):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;One plane&#39;s emittance changed by more than </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">%, &quot;</span>
                <span class="s2">&quot;setting flag to recompute coefficients before next kick.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span> <span class="o">=</span> <span class="kc">True</span></div>



<span class="c1"># ----- Classes to Compute and Apply IBS Kicks ----- #</span>


<div class="viewcode-block" id="SimpleKickIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.SimpleKickIBS">[docs]</a>
<span class="k">class</span> <span class="nc">SimpleKickIBS</span><span class="p">(</span><span class="n">KickBasedIBS</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.5.0</span>

<span class="sd">    A single class to compute the simple IBS kicks based on the analytical growth rates.</span>
<span class="sd">    The kicks are implemented according to :cite:`PRAB:Bruce:Simple_IBS_Kicks`, and</span>
<span class="sd">    provide a random distribution of momenta changes based on the growth rates, weighted</span>
<span class="sd">    by the line density of the bunch. The class initiates from a `BeamParameters` and an</span>
<span class="sd">    `OpticsParameters` objects.</span>

<span class="sd">    See the :ref:`simple kicks example &lt;demo-simple-kicks&gt;` for detailed usage.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Beware: this implementation is only valid **above** transition energy. Because</span>
<span class="sd">        this formalism implements a weighted random-component kick, it will *always* lead</span>
<span class="sd">        to emittance growth. Below transition it is common to observe negative growth rates,</span>
<span class="sd">        which would lead to emittance *shrinkage* and therefore the provided kick would have</span>
<span class="sd">        the wrong effect. It is also possible to obtain negative growth rates above transition</span>
<span class="sd">        in some scenarios, and internally this implementation sets the growth rate to 0 if it</span>
<span class="sd">        is found negative. When this happens, a message is logged to inform the user. For any</span>
<span class="sd">        machine operating below transition energy, the kinetic formalism should be used instead</span>
<span class="sd">        (see the `KineticKickIBS` class).</span>

<span class="sd">    .. hint::</span>
<span class="sd">        When determining kick coefficients (see the `compute_kick_coefficients` method),</span>
<span class="sd">        the analytical growth rates are computed. This is done using one of the analytical</span>
<span class="sd">        classes, which is determined internally based on the optics parameters (namely, the</span>
<span class="sd">        presence of vertical dispersion), and set as the `self.analytical_ibs` attribute.</span>
<span class="sd">        Choices are logged to the user. It is always possible to override this choice by</span>
<span class="sd">        manually setting the `self.analytical_ibs` attribute to an instance of the desired</span>
<span class="sd">        analytical implementation (to be found in `xibs.analytical`). It is also possible</span>
<span class="sd">        for the user to provide their own, custom-made analytical implementation, as long as</span>
<span class="sd">        it inherits from the `AnalyticalIBS` class and implements the API defined therein.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for IBS computations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the IBS computations.</span>
<span class="sd">        analytical_ibs (AnalyticalIBS): an internal analytical class for growth rates</span>
<span class="sd">            calculation, which is determined automatically. Can be overridden by the user</span>
<span class="sd">            by setting this attribute manually.</span>
<span class="sd">        auto_recompute_coefficients_percent (float): Optional. If given, a check is performed after</span>
<span class="sd">            kicking the particles to determine if recomputing the kick coefficients is necessary, in</span>
<span class="sd">            which case it will be done before the next kick. **Please provide a value as a percentage</span>
<span class="sd">            of the emittance increase**. For instance, if one provides `12` after kicking a check is</span>
<span class="sd">            done to see if the emittance grew by more than 12% in any plane, and if so the coefficients</span>
<span class="sd">            will be automatically recomputed before the next kick. Defaults to `None` (no checks done,</span>
<span class="sd">            no auto-recomputing).</span>
<span class="sd">        kick_coefficients (IBSKickCoefficients): the computed IBS kick coefficients. This</span>
<span class="sd">            self-updates when they are computed with the `compute_kick_coefficients` method.</span>
<span class="sd">            It can also be set manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span>
        <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">,</span>
        <span class="n">auto_recompute_coefficients_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># First, we check that we are above transition and raise and error if not (not applicable)</span>
        <span class="k">if</span> <span class="n">optics</span><span class="o">.</span><span class="n">slip_factor</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># we are below transition (xsuite convention: slip factor &gt; 0 above)</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The provided optics parameters indicate that the machine is below transition, &quot;</span>
                <span class="s2">&quot;which is incompatible with SimpleKickIBS (see documentation). &quot;</span>
                <span class="s2">&quot;Use the kinetic formalism with KineticKickIBS instead.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;SimpleKickIBS is not compatible with machines operating below transition. &quot;</span>
                <span class="s2">&quot;Please see the documentation and use the kinetic formalism with KineticKickIBS instead.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># If we made it here, SimpleKickIBS is a valid implementation, let&#39;s instantiate from KickBasedIBS</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">,</span> <span class="n">auto_recompute_coefficients_percent</span><span class="p">)</span>  <span class="c1"># also sets self.kick_coefficients (to None)</span>
        <span class="c1"># Analytical implementation for growth rates calculation, can be overridden by the user</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Non-zero vertical dispersion detected in the lattice, using Bjorken &amp; Mtingwa formalism&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analytical_ibs</span><span class="p">:</span> <span class="n">AnalyticalIBS</span> <span class="o">=</span> <span class="n">BjorkenMtingwaIBS</span><span class="p">(</span><span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No vertical dispersion in the lattice, using Nagaitsev formalism&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analytical_ibs</span><span class="p">:</span> <span class="n">AnalyticalIBS</span> <span class="o">=</span> <span class="n">NagaitsevIBS</span><span class="p">(</span><span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This can be overridden manually, by explicitely setting the self.analytical_ibs attribute&quot;</span><span class="p">)</span>
        <span class="c1"># fmt: on</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">analytical_ibs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnalyticalIBS</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The analytical IBS implementation used for growth rates calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analytical_ibs</span>

    <span class="nd">@analytical_ibs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">analytical_ibs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">AnalyticalIBS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The analytical_ibs has a setter so that .beam_params and .optics are updated when it is set.&quot;&quot;&quot;</span>
        <span class="c1"># fmt: off</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Overwriting the analytical ibs implementation used for growth rates calculation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_analytical_ibs</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Re-pointing the instance&#39;s beam and optics parameters to that of the new analytical implementation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analytical_ibs</span><span class="o">.</span><span class="n">beam_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analytical_ibs</span><span class="o">.</span><span class="n">optics</span>
        <span class="c1"># fmt: on</span>

    <span class="k">def</span> <span class="nf">_check_coefficients_presence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this before trying to apply kicks to first check the necessarykick coefficients are present.</span>
<span class="sd">        If not, sets a flag to compute them, which will be done a bit later after exiting this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempted to apply IBS kick without kick coefficients, will compute them first.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="SimpleKickIBS.compute_kick_coefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.SimpleKickIBS.compute_kick_coefficients">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_kick_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSKickCoefficients</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Computes the ``IBS`` kick coefficients, named :math:`K_x, K_y` and :math:`K_z` in this</span>
<span class="sd">        code base, from analytical growth rates. The coefficients correspond to the right-hand</span>
<span class="sd">        side of Eq (8) in :cite:`PRAB:Bruce:Simple_IBS_Kicks` without the line density :math:`\rho_t(t)`</span>
<span class="sd">        and random component :math:`r`.</span>

<span class="sd">        The kick coefficient corresponds to the scaling of the generated random distribution :math:`r` and</span>
<span class="sd">        is expressed as :math:`K_u = \sigma_{p_u} \sqrt{2 T^{-1}_{IBS_u} T_{rev} \sigma_t \sqrt{\pi}}`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This functionality is separate from the kick application as it internally</span>
<span class="sd">            triggers the computation of the analytical growth rates. Since this step</span>
<span class="sd">            is computationally intensive and one might not necessarily want to recompute</span>
<span class="sd">            the rates before every kick application.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps, which are related to</span>
<span class="sd">            different terms in Eq (8) of :cite:`PRAB:Bruce:Simple_IBS_Kicks`:</span>

<span class="sd">                - Computes various properties from the non-lost particles in the bunch (:math:`\sigma_{x,y,\delta,t}`).</span>
<span class="sd">                - Computes the standard deviation of momenta for each plane (:math:`\sigma_{p_u}`).</span>
<span class="sd">                - Computes the constant term :math:`\sqrt{2 T_{rev} \sqrt{\pi}}`.</span>
<span class="sd">                - Computes the analytical growth rates :math:`T_{x,y,z}` (:math:`T^{-1}_{IBS_u}` in Eq (8)).</span>
<span class="sd">                - Computes, stores and returns the kick coefficients.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the particles to apply the IBS kicks to.</span>
<span class="sd">            **kwargs: any keyword arguments will be passed to the growth rates calculation call</span>
<span class="sd">                (`self.analytical_ibs.growth_rates`). Note that `epsx`, `epsy`, `sigma_delta`,</span>
<span class="sd">                and `bunch_length` are already provided as positional-only arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `IBSKickCoefficients` object with the computed coefficients used for the kick application.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Start with getting the nplike_lib from the particles&#39; context, to compute on the context device</span>
        <span class="n">nplike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">nplike_lib</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the momentum spread, bunch length and (geometric) emittances from the Particles object</span>
        <span class="c1"># Indexing at 0 as this end / start of machine is when we kick (after a line.track)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing emittances, momentum spread and bunch length from particles&quot;</span><span class="p">)</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_bunch_length</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_sigma_delta</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_geom_epsx</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_geom_epsy</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing standard deviation of (normalized) momenta, corresponding to sigma_{pu} in Eq (8) of reference</span>
        <span class="c1"># Normalized: for momentum we have to multiply with gamma = beta / (1 + alpha^2), beta is included in the</span>
        <span class="c1"># std of p[xy]. If bunch is rotated, the std takes from the &quot;other plane&quot; so we normalize to compensate.</span>
        <span class="n">sigma_px_normalized</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sigma_py_normalized</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determine the &quot;scaling factor&quot;, corresponding to 2 * sigma_t * sqrt(pi) in Eq (8) of reference</span>
        <span class="n">zeta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">zeta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># careful to only consider active particles</span>
        <span class="n">bunch_length_rms</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>  <span class="c1"># rms bunch length in [m]</span>
        <span class="n">scaling_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">bunch_length_rms</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing the analytical IBS growth rates</span>
        <span class="n">growth_rates</span><span class="p">:</span> <span class="n">IBSGrowthRates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analytical_ibs</span><span class="o">.</span><span class="n">growth_rates</span><span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">geom_epsy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma_delta</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">bunch_length</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span> <span class="o">=</span> <span class="n">astuple</span><span class="p">(</span><span class="n">growth_rates</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Making sure we do not have negative growth rates (see class docstring warning for detail)</span>
        <span class="n">Tx</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">Tx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">Tx</span><span class="p">)</span>
        <span class="n">Ty</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">Ty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ty</span><span class="p">)</span>
        <span class="n">Tz</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">Tz</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">Tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">rate</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">rate</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span><span class="p">)):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;At least one IBS growth rate was negative, and was set to 0&quot;</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the kick coefficients - see function docstring for exact definition</span>
        <span class="c1"># For the longitudinal plane, since the values are computed from P/P but applied to the E/E</span>
        <span class="c1"># (the particles.delta in Xsuite), we need to multiply by beta_rel**2 to adapt</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing and applying the kicks to the particles&quot;</span><span class="p">)</span>
        <span class="n">Kx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_px_normalized</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="n">Tx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">revolution_frequency</span><span class="p">)</span>
        <span class="n">Ky</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_py_normalized</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="n">Ty</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">revolution_frequency</span><span class="p">)</span>
        <span class="n">Kz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">sigma_delta</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">scaling_factor</span> <span class="o">*</span> <span class="n">Tz</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">revolution_frequency</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">IBSKickCoefficients</span><span class="p">(</span><span class="n">Kx</span><span class="p">,</span> <span class="n">Ky</span><span class="p">,</span> <span class="n">Kz</span><span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Self-update the instance&#39;s attributes and then return the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_coefficients_computations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_apply_formalism_ibs_kick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.0</span>

<span class="sd">        Compute the momentum kick to apply based on the provided `xtrack.Particles` object and the</span>
<span class="sd">        analytical growth rates for the lattice. The kicks are implemented according to Eq (8) of</span>
<span class="sd">        :cite:`PRAB:Bruce:Simple_IBS_Kicks`.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the `xtrack.Particles` object to apply ``IBS`` kicks to.</span>
<span class="sd">            n_slices (int): the number of slices to use for the computation of the line density.</span>
<span class="sd">                Defaults to 40.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Start with getting the the particles&#39; context, to be able to move data on the context device</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">_context</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the line density - this is the rho_t(t) term in Eq (8) of reference</span>
        <span class="n">rho_t</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_density</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">)</span>  <span class="c1"># does NOT include _factor</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determining size of arrays for kicks to apply: only the non-lost particles in the bunch</span>
        <span class="n">_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># same for py and delta</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determining kicks - this corresponds to the full result of Eq (8) of reference</span>
        <span class="c1"># In theory, .normal(0, 1, _size) * factor and .normal(0, factor, _size) are the same (try it) but</span>
        <span class="c1"># in practice the resulting kick is not physically accurate. The same is observed in C++ code (see</span>
        <span class="c1"># for instance BLonD) so we use the coefficients as scale here, which is correct and benchmarked.</span>
        <span class="c1"># fmt: off</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining kicks to apply&quot;</span><span class="p">)</span>
        <span class="n">RNG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="n">rho_t_</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">delta_px</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="o">.</span><span class="n">Kx</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span><span class="p">)</span>
        <span class="n">delta_py</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="o">.</span><span class="n">Ky</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">_size</span><span class="p">)</span> <span class="o">*</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span><span class="p">)</span>
        <span class="n">delta_delta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="o">.</span><span class="n">Kz</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Apply the kicks to the particles - just move the computed deltas to device and apply</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Applying momenta kicks to the particles (on px, py and delta properties)&quot;</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_px</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_py</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_delta</span><span class="p">)</span></div>

        <span class="c1"># fmt: on</span>


<div class="viewcode-block" id="KineticKickIBS">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KineticKickIBS">[docs]</a>
<span class="k">class</span> <span class="nc">KineticKickIBS</span><span class="p">(</span><span class="n">KickBasedIBS</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.7.0</span>

<span class="sd">    A single class to compute the IBS diffusion and friction coefficients according</span>
<span class="sd">    to the kinetic IBS formalism of :cite:`NuclInstr:Zenkevich:Kinetic_IBS`.</span>
<span class="sd">    The class initiates from a `BeamParameters` and an `OpticsParameters` objects.</span>

<span class="sd">    See the :ref:`kinetic kicks example &lt;demo-kinetic-kicks&gt;` for detailed usage.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        beam_parameters (BeamParameters): the beam parameters to use for IBS computations.</span>
<span class="sd">        optics (OpticsParameters): the optics parameters to use for the IBS computations.</span>
<span class="sd">        diffusion_coefficients (DiffusionCoefficients): the computed diffusion coefficients</span>
<span class="sd">            from the kinetic theory. This attribute self-updates when coefficients are computed</span>
<span class="sd">            with the `compute_kick_coefficients` method. It can also be set manually.</span>
<span class="sd">        friction_coefficients (FrictionCoefficients): the computed friction coefficients</span>
<span class="sd">            from the kinetic theory. This attribute self-updates when coefficients are computed</span>
<span class="sd">            with the `compute_kick_coefficients` method. It can also be set manually.</span>
<span class="sd">        auto_recompute_coefficients_percent (float): Optional. If given, a check is performed after</span>
<span class="sd">            kicking the particles to determine if recomputing the kick coefficients is necessary, in</span>
<span class="sd">            which case it will be done before the next kick. **Please provide a value as a percentage</span>
<span class="sd">            of the emittance increase**. For instance, if one provides `12` after kicking a check is</span>
<span class="sd">            done to see if the emittance grew by more than 12% in any plane, and if so the coefficients</span>
<span class="sd">            will be automatically recomputed before the next kick. Defaults to `None` (no checks done,</span>
<span class="sd">            no auto-recomputing).</span>
<span class="sd">        kick_coefficients (IBSKickCoefficients): the computed IBS kick coefficients from</span>
<span class="sd">            the kinetic theory, determined from the diffusion and friction coefficients. This</span>
<span class="sd">            attribute self-updates when coefficients are computed with the `compute_kick_coefficients`</span>
<span class="sd">            method. It can also be set manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beam_params</span><span class="p">:</span> <span class="n">BeamParameters</span><span class="p">,</span>
        <span class="n">optics</span><span class="p">:</span> <span class="n">OpticsParameters</span><span class="p">,</span>
        <span class="n">auto_recompute_coefficients_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">beam_params</span><span class="p">,</span> <span class="n">optics</span><span class="p">,</span> <span class="n">auto_recompute_coefficients_percent</span>
        <span class="p">)</span>  <span class="c1"># also sets self.kick_coefficients</span>
        <span class="c1"># These self-update when computed, but can be overwritten by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_coefficients</span><span class="p">:</span> <span class="n">DiffusionCoefficients</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">friction_coefficients</span><span class="p">:</span> <span class="n">FrictionCoefficients</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="KineticKickIBS.compute_kick_coefficients">
<a class="viewcode-back" href="../../modules/index.html#xibs.kicks.KineticKickIBS.compute_kick_coefficients">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_kick_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IBSKickCoefficients</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.7.0</span>

<span class="sd">        Computes the ``IBS`` kick coefficients, named :math:`K_x, K_y` and :math:`K_z` in this</span>
<span class="sd">        code base, from the friction and diffusion terms of the kinetic theory as expressed in</span>
<span class="sd">        :cite:`NuclInstr:Zenkevich:Kinetic_IBS`, and using terms from Nagaitsev&#39;s formalism</span>
<span class="sd">        (:cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`) as determined by M. Zampetakis</span>
<span class="sd">        (:cite:`CERN:Zampetakis:Implementation_IBS_Kicks`). This will compute both diffusion and</span>
<span class="sd">        friction coefficients from this formalism, which will be stored and updated internally</span>
<span class="sd">        into the `diffusion_coefficients` and `friction_coefficients` attributes. It returns</span>
<span class="sd">        an `IBSKickCoefficients` object with the computed coefficients (diffusion - friction).</span>

<span class="sd">        .. note::</span>
<span class="sd">            This functionality is separate from the kick application because it internally triggers</span>
<span class="sd">            the computation of the analytical growth rates, and we don&#39;t necessarily want to</span>
<span class="sd">            recompute these at every turn. Meanwhile, the kicks **should** be applied at every turn.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            The calculation is done according to the following steps:</span>

<span class="sd">                - Computes various terms from :cite:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation` as well as elliptic integrals.</span>
<span class="sd">                - Computes the :math:`D_{xx}, D_{xz}, D_{yy}, D_{zz}, K_x, K_y` and :math:`K_z` terms.</span>
<span class="sd">                - Computes diffusion and friction coefficients from the above, following :cite:`CERN:Zampetakis:Implementation_IBS_Kicks`.</span>
<span class="sd">                - Computes and returns kick coefficients (as the difference between diffusion and friction).</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the particles to apply the IBS kicks to.</span>
<span class="sd">            **kwargs: if `bunched` is found in keyword arguments it will be passed to the</span>
<span class="sd">                coulomb logarithm calculation. A default value of `True` is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `IBSKickCoefficients` object with the computed coefficients used for the kick application.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Start with getting the nplike_lib from the particles&#39; context, to compute on the context device</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">_context</span>
        <span class="n">nplike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nplike_lib</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the momentum spread, bunch length and (geometric) emittances from the Particles object</span>
        <span class="c1"># Indexing at 0 as this end / start of machine is when we kick (after a line.track)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing emittances, momentum spread and bunch length from particles&quot;</span><span class="p">)</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_bunch_length</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_sigma_delta</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">geom_epsx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_geom_epsx</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">geom_epsy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_geom_epsy</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sigma_x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_sigma_x</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">sigma_y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_sigma_y</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Moving some necessary arrays to device for later computation</span>
        <span class="n">s</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">alfx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">betx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">betx</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">bety</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">bety</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">dx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">dpx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">dpx</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">phix</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="n">betx</span><span class="p">,</span> <span class="n">alfx</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dpx</span><span class="p">)</span>  <span class="c1"># on device as all dependent terms are</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Allocating some values to simple variables for readability later</span>
        <span class="n">gammar</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">gamma_rel</span>
        <span class="n">betar</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">beta_rel</span>
        <span class="n">n_part</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">n_part</span>
        <span class="n">classical_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="o">.</span><span class="n">particle_classical_radius_m</span>
        <span class="n">pi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">circumference</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">circumference</span>
        <span class="c1"># fmt: off</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing the constants from Eq (18-21) in Nagaitsev paper - on device as all dependent terms are</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">betx</span> <span class="o">/</span> <span class="n">geom_epsx</span>
        <span class="n">ay</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">/</span> <span class="n">geom_epsy</span>
        <span class="n">a_s</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">a1</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a_s</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">a2</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">-</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a_s</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">sqrt_term</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ax</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># These are from Eq (22-24) in Nagaitsev paper, eigen values of A matrix (L matrix in B&amp;M)</span>
        <span class="c1"># Also all on device as their dependent terms are on device</span>
        <span class="n">lambda_1</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">ay</span>
        <span class="n">lambda_2</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">sqrt_term</span>
        <span class="n">lambda_3</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">sqrt_term</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># These are the R_D terms to compute, from Eq (25-27) in Nagaitsev paper (at each element of the lattice)</span>
        <span class="c1"># Since cupy does not have an elliprd equivalent, we go back to CPU and let scipy handle this</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing elliptic integrals R1, R2 and R3&quot;</span><span class="p">)</span>
        <span class="n">lbd1_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">lambda_1</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">lbd2_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">lambda_2</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">lbd3_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">lambda_3</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">R1_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">elliprd</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lbd2_</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lbd3_</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lbd1_</span><span class="p">)</span> <span class="o">/</span> <span class="n">lbd1_</span>  <span class="c1"># on CPU</span>
        <span class="n">R2_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">elliprd</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lbd3_</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lbd1_</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lbd2_</span><span class="p">)</span> <span class="o">/</span> <span class="n">lbd2_</span>  <span class="c1"># on CPU</span>
        <span class="n">R3_</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lbd1_</span> <span class="o">*</span> <span class="n">lbd2_</span> <span class="o">/</span> <span class="n">lbd3_</span><span class="p">)</span> <span class="o">-</span> <span class="n">lbd1_</span> <span class="o">*</span> <span class="n">R1_</span> <span class="o">/</span> <span class="n">lbd3_</span> <span class="o">-</span> <span class="n">lbd2_</span> <span class="o">*</span> <span class="n">R2_</span> <span class="o">/</span> <span class="n">lbd3_</span>  <span class="c1"># on CPU</span>
        <span class="c1"># We transport these results back to device</span>
        <span class="n">R1</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">R1_</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">R2</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">R2_</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">R3</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">R3_</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the coulomb logarithm from an analytical class then the rest of the constant term in</span>
        <span class="c1"># Eq (30-32) of Nagaitsev&#39;s paper - all this below are CPU computations</span>
        <span class="n">analytical</span> <span class="o">=</span> <span class="n">NagaitsevIBS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="p">)</span>  <span class="c1"># the formalism does not matter</span>
        <span class="n">bunched</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bunched&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">coulomb_logarithm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">analytical</span><span class="o">.</span><span class="n">coulomb_log</span><span class="p">(</span><span class="n">geom_epsx</span><span class="p">,</span> <span class="n">geom_epsy</span><span class="p">,</span> <span class="n">sigma_delta</span><span class="p">,</span> <span class="n">bunch_length</span><span class="p">,</span> <span class="n">bunched</span><span class="p">)</span>
        <span class="n">rest_of_constant_term</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">n_part</span> <span class="o">*</span> <span class="n">classical_radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">betar</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">5</span> <span class="o">*</span> <span class="n">bunch_length</span><span class="p">)</span>
        <span class="n">full_constant_term</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">rest_of_constant_term</span> <span class="o">*</span> <span class="n">coulomb_logarithm</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing the Dxx, Dxz, etc terms from Nagaitsev terms above, according to the expressions derived</span>
        <span class="c1"># by Michalis (see backup slides in his presentation at https://indico.cern.ch/event/1140639)</span>
        <span class="c1"># All below are on device as all dependent terms are on device</span>
        <span class="n">Dzz</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">+</span> <span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">+</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span>  <span class="c1"># on device</span>
        <span class="n">Kz</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">+</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span>            <span class="c1"># on device</span>
        <span class="n">Dxx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">+</span> <span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">+</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span>              <span class="c1"># on device</span>
        <span class="n">Kx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">R2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">)</span> <span class="o">+</span> <span class="n">R3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">sqrt_term</span><span class="p">))</span>                        <span class="c1"># on device</span>
        <span class="n">Dxz</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">gammar</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">R3</span> <span class="o">-</span> <span class="n">R2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt_term</span>                              <span class="c1"># on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Computing integrands for the diffusion and friction terms from the above (also from Michalis,</span>
        <span class="c1"># see slide 18 of his presentation for instance) - all of these are on device as all dependent terms are</span>
        <span class="n">Dx_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">betx</span> <span class="o">*</span> <span class="p">(</span><span class="n">Dxx</span> <span class="o">+</span> <span class="n">Dzz</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dxz</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">Fx_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">betx</span> <span class="o">*</span> <span class="p">(</span><span class="n">Kx</span> <span class="o">+</span> <span class="n">Kz</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">betx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">phix</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>          <span class="c1"># on device</span>
        <span class="n">Dy_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">*</span> <span class="p">(</span><span class="n">R2</span> <span class="o">+</span> <span class="n">R3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>                                        <span class="c1"># on device</span>
        <span class="n">Fy_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">bety</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span><span class="p">)</span>  <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>                                        <span class="c1"># on device</span>
        <span class="n">Dz_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Dzz</span> <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>                                                     <span class="c1"># on device</span>
        <span class="n">Fz_integrand</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Kz</span> <span class="o">/</span> <span class="p">(</span><span class="n">circumference</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">*</span> <span class="n">sigma_y</span><span class="p">)</span>                                                      <span class="c1"># on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Integrating them to obtain the diffusion and friction coefficients</span>
        <span class="n">Dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Dx_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsx</span>
        <span class="n">Dy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Dy_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsy</span>
        <span class="n">Dz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Dz_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">Fx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fx_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsx</span>
        <span class="n">Fy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fy_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">geom_epsy</span>
        <span class="n">Fz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fz_integrand</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">full_constant_term</span> <span class="o">/</span> <span class="n">sigma_delta</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Generate and store the coefficients in a DiffusionCoefficients and FrictionCoefficients object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_coefficients</span> <span class="o">=</span> <span class="n">DiffusionCoefficients</span><span class="p">(</span><span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">friction_coefficients</span> <span class="o">=</span> <span class="n">FrictionCoefficients</span><span class="p">(</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Self-update the instance&#39;s attributes and then return the results: kick coefficients</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">IBSKickCoefficients</span><span class="p">(</span><span class="n">Dx</span> <span class="o">-</span> <span class="n">Fx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">-</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Dz</span> <span class="o">-</span> <span class="n">Fz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_coefficients_computations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_check_coefficients_presence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this before trying to apply kicks to first check the necessarykick coefficients are present.</span>
<span class="sd">        If not, sets a flag to compute them, which will be done a bit later after exiting this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">coeffs</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kick_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">friction_coefficients</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempted to apply IBS kick without kick coefficients, will compute them first.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_need_to_recompute_coefficients</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_apply_formalism_ibs_kick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="s2">&quot;xtrack.Particles&quot;</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.7.0</span>

<span class="sd">        Computes the momentum kicks to apply based on the provided `xtrack.Particles` object and</span>
<span class="sd">        the previously computed kick coefficients. The kick is applied as described in</span>
<span class="sd">        :cite:`NuclInstr:Zenkevich:Kinetic_IBS` and :cite:`CERN:Zampetakis:Implementation_IBS_Kicks`.</span>

<span class="sd">        Args:</span>
<span class="sd">            particles (xtrack.Particles): the `xtrack.Particles` object to apply ``IBS`` kicks to.</span>
<span class="sd">            n_slices (int): the number of slices to use for the computation of the line density.</span>
<span class="sd">                Defaults to 40.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Start with getting the nplike_lib from the particles&#39; context, to compute on the context device</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">_context</span>
        <span class="n">nplike</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nplike_lib</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the line density - this is the rho_t(t) term in Eq (8) of</span>
        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">revolution_frequency</span>
        <span class="n">rho_t</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_density</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">n_slices</span><span class="p">)</span>  <span class="c1"># computed on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the bunch_length * 2 * sqrt(pi) factor for the kicks</span>
        <span class="n">bunch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_bunch_length</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
        <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">bunch_length</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Compute the momentum spread and standard deviation of (normalized) momenta from particles object</span>
        <span class="c1"># Normalized: for momentum we have to multiply with gamma = beta / (1 + alpha^2), beta is included in the</span>
        <span class="c1"># std of p[xy]. If bunch is rotated, the std takes from the &quot;other plane&quot; so we normalize to compensate.</span>
        <span class="c1"># fmt: off</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing momentum spread and momenta&#39;s standard deviations&quot;</span><span class="p">)</span>
        <span class="n">sigma_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_sigma_delta</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">sigma_px_normalized</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="n">sigma_py_normalized</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nplike</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">nplike</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">optics</span><span class="o">.</span><span class="n">alfy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determining kicks from the friction forces (see referenced Michalis presentation)</span>
        <span class="c1"># Friction term is in absolute and depends on the momentum. If we have a distribution then</span>
        <span class="c1"># the friction term is with respect to the center -&gt; if the beam is off-center we need to</span>
        <span class="c1"># compensate for this so we use deviation of particle p[xy] from distribution mean</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining friction kicks&quot;</span><span class="p">)</span>
        <span class="n">dev_px</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nplike</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>           <span class="c1"># on device</span>
        <span class="n">dev_py</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nplike</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>           <span class="c1"># on device</span>
        <span class="n">dev_delta</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nplike</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># on device</span>
        <span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span> <span class="o">=</span> <span class="n">astuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">friction_coefficients</span><span class="p">)</span>
        <span class="n">delta_px_friction</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Fx</span> <span class="o">*</span> <span class="n">dev_px</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="n">factor</span>        <span class="c1"># on device</span>
        <span class="n">delta_py_friction</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Fy</span> <span class="o">*</span> <span class="n">dev_py</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="n">factor</span>        <span class="c1"># on device</span>
        <span class="n">delta_delta_friction</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Fz</span> <span class="o">*</span> <span class="n">dev_delta</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="n">factor</span>  <span class="c1"># on device</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Determining kicks from the friction forces (see referenced Michalis presentation)</span>
        <span class="c1"># Since cupy does not provide a default_rng().normal method, we go back to CPU and let scipy handle this</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining diffusion kicks&quot;</span><span class="p">)</span>
        <span class="n">RNG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="n">_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># same for py and delta</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dz</span> <span class="o">=</span> <span class="n">astuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diffusion_coefficients</span><span class="p">)</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dz</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Dx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">Dy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">Dz</span><span class="p">)</span>                            <span class="c1"># on CPU</span>
        <span class="n">sig_px_norm_</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">sigma_px_normalized</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">sig_py_norm_</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">sigma_py_normalized</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="n">sig_delta_</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">sigma_delta</span><span class="p">)</span>            <span class="c1"># on CPU</span>
        <span class="n">rho_t_</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_from_context_array</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>                      <span class="c1"># on CPU</span>
        <span class="n">factor_</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>                                                 <span class="c1"># on CPU</span>
        <span class="n">delta_px_diffusion</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">sig_px_norm_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">Dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">)</span>   <span class="c1"># on CPU</span>
        <span class="n">delta_py_diffusion</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">sig_py_norm_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">Dy</span><span class="p">)</span> <span class="o">*</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">)</span>   <span class="c1"># on CPU</span>
        <span class="n">delta_delta_diffusion</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">sig_delta_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">Dz</span><span class="p">)</span> <span class="o">*</span> <span class="n">RNG</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho_t_</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">)</span>  <span class="c1"># on CPU</span>
        <span class="c1"># ----------------------------------------------------------------------------------------------</span>
        <span class="c1"># Now we can apply all momenta kicks (friction and diffusion) to the particles - on device directly</span>
        <span class="c1"># fmt: on</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Applying friction kicks to the particles (on px, py and delta properties)&quot;</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta_px_friction</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta_py_friction</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta_delta_friction</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Applying diffusion kicks to the particles (on px, py and delta properties)&quot;</span><span class="p">)</span>
        <span class="c1"># Since the generated were done by numpy we make sure to convert to device first</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">px</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_px_diffusion</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">py</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_py_diffusion</span><span class="p">)</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">particles</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">context</span><span class="o">.</span><span class="n">nparray_to_context_array</span><span class="p">(</span><span class="n">delta_delta_diffusion</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Soubelet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>