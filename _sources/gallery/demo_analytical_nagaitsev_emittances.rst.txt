
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_analytical_nagaitsev_emittances.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_analytical_nagaitsev_emittances.py:


.. _demo-analytical-nagaitsev:

=====================================================================
Nagaitsev Formalism - Analytical Growth Rates and Emittance Evolution
=====================================================================

This example shows how to use the `~.xibs.analytical.NagaitsevIBS` class
to calculate IBS growth rates and emittances evolutions analytically.

We will demonstrate using an `xtrack.Line` of the ``CLIC`` damping ring,
for a positron beam.

.. GENERATED FROM PYTHON SOURCE LINES 15-38

.. code-block:: Python

    from dataclasses import dataclass

    import matplotlib.pyplot as plt
    import numpy as np
    import xpart as xp
    import xtrack as xt

    from xibs.analytical import NagaitsevIBS
    from xibs.inputs import BeamParameters, OpticsParameters

    plt.rcParams.update(
        {
            "font.family": "serif",
            "font.size": 20,
            "axes.titlesize": 20,
            "axes.labelsize": 20,
            "xtick.labelsize": 20,
            "ytick.labelsize": 20,
            "legend.fontsize": 15,
            "figure.titlesize": 20,
        }
    )








.. GENERATED FROM PYTHON SOURCE LINES 40-42

Let's start by defining the line and particle information, as well as some
parameters for later use:

.. GENERATED FROM PYTHON SOURCE LINES 42-53

.. code-block:: Python


    line_file = "lines/chrom-corr_DR.newlattice_2GHz.json"
    harmonic_number = 2852
    rf_voltage = 4.5  # in MV
    energy_loss = 0  # let's pretend ;)
    bunch_intensity = 4.4e9
    sigma_z = 1.58e-3
    nemitt_x = 5.6644e-07
    nemitt_y = 3.7033e-09
    n_part = int(5e3)  # for this example let's not use too many particles








.. GENERATED FROM PYTHON SOURCE LINES 54-58

Setting up line and particles
-----------------------------
Let's start by loading the `xtrack.Line`, activating RF cavities and
generating a matched Gaussian bunch:

.. GENERATED FROM PYTHON SOURCE LINES 58-81

.. code-block:: Python


    line = xt.Line.from_json(line_file)
    line.build_tracker(extra_headers=["#define XTRACK_MULTIPOLE_NO_SYNRAD"])

    # ----- Power accelerating cavities ----- #
    cavities = [element for element in line.elements if isinstance(element, xt.Cavity)]
    for cavity in cavities:
        cavity.lag = 180

    p0 = xp.Particles(mass0=xp.ELECTRON_MASS_EV, q0=1, p0c=2.86e9)
    line.particle_ref = p0
    twiss = line.twiss()

    particles = xp.generate_matched_gaussian_bunch(
        num_particles=n_part,
        total_intensity_particles=bunch_intensity,
        nemitt_x=nemitt_x,
        nemitt_y=nemitt_y,
        sigma_z=sigma_z,
        particle_ref=p0,
        line=line,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Init: interval 718, total 71796
    Loading line from dict:   0% (0/71796 iterations)    Loading line from dict:   1% (718/71796 iterations)    Loading line from dict:   2% (1436/71796 iterations)    Loading line from dict:   3% (2154/71796 iterations)    Loading line from dict:   4% (2872/71796 iterations)    Loading line from dict:   5% (3590/71796 iterations)    Loading line from dict:   6% (4308/71796 iterations)    Loading line from dict:   7% (5026/71796 iterations)    Loading line from dict:   8% (5744/71796 iterations)    Loading line from dict:   9% (6462/71796 iterations)    Loading line from dict:  10% (7180/71796 iterations)    Loading line from dict:  11% (7898/71796 iterations)    Loading line from dict:  12% (8616/71796 iterations)    Loading line from dict:  13% (9334/71796 iterations)    Loading line from dict:  14% (10052/71796 iterations)    Loading line from dict:  15% (10770/71796 iterations)    Loading line from dict:  16% (11488/71796 iterations)    Loading line from dict:  17% (12206/71796 iterations)    Loading line from dict:  18% (12924/71796 iterations)    Loading line from dict:  19% (13642/71796 iterations)    Loading line from dict:  20% (14360/71796 iterations)    Loading line from dict:  21% (15078/71796 iterations)    Loading line from dict:  22% (15796/71796 iterations)    Loading line from dict:  23% (16514/71796 iterations)    Loading line from dict:  24% (17232/71796 iterations)    Loading line from dict:  25% (17950/71796 iterations)    Loading line from dict:  26% (18668/71796 iterations)    Loading line from dict:  27% (19386/71796 iterations)    Loading line from dict:  28% (20104/71796 iterations)    Loading line from dict:  29% (20822/71796 iterations)    Loading line from dict:  30% (21540/71796 iterations)    Loading line from dict:  31% (22258/71796 iterations)    Loading line from dict:  32% (22976/71796 iterations)    Loading line from dict:  33% (23694/71796 iterations)    Loading line from dict:  34% (24412/71796 iterations)    Loading line from dict:  35% (25130/71796 iterations)    Loading line from dict:  36% (25848/71796 iterations)    Loading line from dict:  37% (26566/71796 iterations)    Loading line from dict:  38% (27284/71796 iterations)    Loading line from dict:  39% (28002/71796 iterations)    Loading line from dict:  40% (28720/71796 iterations)    Loading line from dict:  41% (29438/71796 iterations)    Loading line from dict:  42% (30156/71796 iterations)    Loading line from dict:  43% (30874/71796 iterations)    Loading line from dict:  44% (31592/71796 iterations)    Loading line from dict:  45% (32310/71796 iterations)    Loading line from dict:  46% (33028/71796 iterations)    Loading line from dict:  47% (33746/71796 iterations)    Loading line from dict:  48% (34464/71796 iterations)    Loading line from dict:  49% (35182/71796 iterations)    Loading line from dict:  50% (35900/71796 iterations)    Loading line from dict:  51% (36618/71796 iterations)    Loading line from dict:  52% (37336/71796 iterations)    Loading line from dict:  53% (38054/71796 iterations)    Loading line from dict:  54% (38772/71796 iterations)    Loading line from dict:  55% (39490/71796 iterations)    Loading line from dict:  56% (40208/71796 iterations)    Loading line from dict:  57% (40926/71796 iterations)    Loading line from dict:  58% (41644/71796 iterations)    Loading line from dict:  59% (42362/71796 iterations)    Loading line from dict:  60% (43080/71796 iterations)    Loading line from dict:  61% (43798/71796 iterations)    Loading line from dict:  62% (44516/71796 iterations)    Loading line from dict:  63% (45234/71796 iterations)    Loading line from dict:  64% (45952/71796 iterations)    Loading line from dict:  65% (46670/71796 iterations)    Loading line from dict:  66% (47388/71796 iterations)    Loading line from dict:  67% (48106/71796 iterations)    Loading line from dict:  68% (48824/71796 iterations)    Loading line from dict:  69% (49542/71796 iterations)    Loading line from dict:  70% (50260/71796 iterations)    Loading line from dict:  71% (50978/71796 iterations)    Loading line from dict:  72% (51696/71796 iterations)    Loading line from dict:  73% (52414/71796 iterations)    Loading line from dict:  74% (53132/71796 iterations)    Loading line from dict:  75% (53850/71796 iterations)    Loading line from dict:  76% (54568/71796 iterations)    Loading line from dict:  77% (55286/71796 iterations)    Loading line from dict:  78% (56004/71796 iterations)    Loading line from dict:  79% (56722/71796 iterations)    Loading line from dict:  80% (57440/71796 iterations)    Loading line from dict:  81% (58158/71796 iterations)    Loading line from dict:  82% (58876/71796 iterations)    Loading line from dict:  83% (59594/71796 iterations)    Loading line from dict:  84% (60312/71796 iterations)    Loading line from dict:  85% (61030/71796 iterations)    Loading line from dict:  86% (61748/71796 iterations)    Loading line from dict:  87% (62466/71796 iterations)    Loading line from dict:  88% (63184/71796 iterations)    Loading line from dict:  89% (63902/71796 iterations)    Loading line from dict:  90% (64620/71796 iterations)    Loading line from dict:  91% (65338/71796 iterations)    Loading line from dict:  92% (66056/71796 iterations)    Loading line from dict:  93% (66774/71796 iterations)    Loading line from dict:  94% (67492/71796 iterations)    Loading line from dict:  95% (68210/71796 iterations)    Loading line from dict:  96% (68928/71796 iterations)    Loading line from dict:  97% (69646/71796 iterations)    Loading line from dict:  98% (70364/71796 iterations)    Loading line from dict:  99% (71082/71796 iterations)    Loading line from dict: 100% (71796/71796 iterations)
    Done loading line from dict.           
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 82-84

We can have a look at the generated particles (see the `xsuite user guide
<https://xsuite.readthedocs.io/en/latest/particlesmanip.html>`_ for more)

.. GENERATED FROM PYTHON SOURCE LINES 84-101

.. code-block:: Python


    fig, (axx, axy, axz) = plt.subplots(3, 1, figsize=(9, 11))

    axx.plot(1e6 * particles.x, 1e5 * particles.px, ".", ms=3)
    axy.plot(1e6 * particles.y, 1e6 * particles.py, ".", ms=3)
    axz.plot(1e3 * particles.zeta, 1e3 * particles.delta, ".", ms=3)

    axx.set_xlabel(r"$x$ [$\mu$m]")
    axx.set_ylabel(r"$p_x$ [$10^{-5}$]")
    axy.set_xlabel(r"$y$ [$\mu$m]")
    axy.set_ylabel(r"$p_y$ [$10^{-3}$]")
    axz.set_xlabel(r"$z$ [$10^{-3}$]")
    axz.set_ylabel(r"$\delta$ [$10^{-3}$]")
    fig.align_ylabels([axx, axy, axz])
    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 102-104

We can compute initial (geometrical) emittances as well as the bunch length
from the `xpart.Particles` object:

.. GENERATED FROM PYTHON SOURCE LINES 104-114

.. code-block:: Python


    sig_x = np.std(particles.x[particles.state > 0])  # horizontal stdev
    sig_y = np.std(particles.y[particles.state > 0])  # vertical stdev
    sig_delta = np.std(particles.delta[particles.state > 0])  # momentum spread

    # Compute horizontal & vertical geometric emittances as well as the bunch length, all in [m]
    geom_epsx = (sig_x**2 - (twiss["dx"][0] * sig_delta) ** 2) / twiss["betx"][0]
    geom_epsy = sig_y**2 / twiss["bety"][0]
    bunch_l = np.std(particles.zeta[particles.state > 0])








.. GENERATED FROM PYTHON SOURCE LINES 115-121

Computing Elliptic Integrals and IBS Growth Rates
-------------------------------------------------
Let us instantiate the `~.xibs.analytical.NagaitsevIBS` class. It is fairly
simple and is done from both the beam parameters of the particles and the
optics parameters of the line. For each of these a specific `dataclass`
is provided in the `~.xibs.inputs` module.

.. GENERATED FROM PYTHON SOURCE LINES 121-126

.. code-block:: Python


    beam_params = BeamParameters(particles)
    optics = OpticsParameters(twiss)
    IBS = NagaitsevIBS(beam_params, optics)








.. GENERATED FROM PYTHON SOURCE LINES 127-131

As a first step, all calculations in rely on the computing of Nagaitsev integrals
:cite:p:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`, which is done with
a dedicated function. These are returned, but also stored internally in the **IBS**
object and will be updated internally each time they are computed.

.. GENERATED FROM PYTHON SOURCE LINES 131-136

.. code-block:: Python


    integrals = IBS.integrals(geom_epsx, geom_epsy, sig_delta)
    print(integrals)
    print(IBS.elliptic_integrals)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    NagaitsevIntegrals(Ix=8.14707866450298e+19, Iy=1.491093391719635e+17, Iz=6.0423112299450955e+23)
    NagaitsevIntegrals(Ix=8.14707866450298e+19, Iy=1.491093391719635e+17, Iz=6.0423112299450955e+23)




.. GENERATED FROM PYTHON SOURCE LINES 137-142

From these the **IBS** growth rates can be computed, which is again done by calling
a dedicated function. If the integrals mentioned above have not been computed yet,
an message will be logged for the user and they will be computed first. Once again,
these are returned but also stored internally and updated internally each time they
are computed.

.. GENERATED FROM PYTHON SOURCE LINES 142-147

.. code-block:: Python


    growth_rates = IBS.growth_rates(geom_epsx, geom_epsy, sig_delta, bunch_l)
    print(growth_rates)
    print(IBS.ibs_growth_rates)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    IBSGrowthRates(Tx=372.23863862005004, Ty=105.1681027060877, Tz=93.07325324981103)
    IBSGrowthRates(Tx=372.23863862005004, Ty=105.1681027060877, Tz=93.07325324981103)




.. GENERATED FROM PYTHON SOURCE LINES 148-152

Please note that the `IBS.growth_rates` method by default re-computes the 
integrals before computing the growth rates. This convenient as usually, one
needs to update the integrals when they want to update the growth rates. It 
can be disabled by setting the `compute_integrals` argument to `False`.

.. GENERATED FROM PYTHON SOURCE LINES 154-159

Computing New Emittances from Growth Rates
------------------------------------------
From these one can compute the emittances at the next time step. For the emittances
at the next turn, once should use :math:`1 / f_{rev}` as the time step, which
is the default value used if it is not provided.

.. GENERATED FROM PYTHON SOURCE LINES 159-168

.. code-block:: Python


    new_geom_epsx, new_geom_epsy, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
        geom_epsx, geom_epsy, sig_delta, bunch_l
    )
    print(f"Next time step geometrical epsilon_x = {new_geom_epsx} m")
    print(f"Next time step geometrical epsilon_y = {new_geom_epsy} m")
    print(f"Next time step sigma_delta = {new_sig_delta}")
    print(f"Next time step bunch length = {new_bunch_length} m")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Next time step geometrical epsilon_x = 1.0029625869186469e-10 m
    Next time step geometrical epsilon_y = 6.494708816271611e-13 m
    Next time step sigma_delta = 0.0017244666207643102
    Next time step bunch length = 0.0015873445991573057 m




.. GENERATED FROM PYTHON SOURCE LINES 169-176

Analytical Evolution for Many Turns
-----------------------------------
One can then analytically look at the evolution through many turns by looping
over this calculation. Let's do this for 10 000 turns, re-computing the elliptic
integrals and the IBS growth rates every 200 turns. The more frequent this update
the more physically accurate the results will be, but the longer the simulation
as this computation is the most compute-intensive process.

.. GENERATED FROM PYTHON SOURCE LINES 176-234

.. code-block:: Python


    nturns = 10_000  # number of turns to loop for
    ibs_step = 200  # frequency at which to re-compute the growth rates in [turns]
    turns = np.arange(nturns, dtype=int)  # array of turns

    # Set up a dataclass to store the results
    @dataclass
    class Records:
        """Dataclass to store (and update) important values through tracking."""

        epsilon_x: np.ndarray
        epsilon_y: np.ndarray
        sig_delta: np.ndarray
        bunch_length: np.ndarray


    # Initialize the dataclass
    turn_by_turn = Records(
        epsilon_x=np.zeros(nturns, dtype=float),
        epsilon_y=np.zeros(nturns, dtype=float),
        sig_delta=np.zeros(nturns, dtype=float),
        bunch_length=np.zeros(nturns, dtype=float),
    )

    # Store the initial values
    turn_by_turn.bunch_length[0] = np.std(particles.zeta[particles.state > 0])
    turn_by_turn.sig_delta[0] = sig_delta
    turn_by_turn.epsilon_x[0] = (sig_x**2 - (twiss["dx"][0] * sig_delta) ** 2) / twiss["betx"][0]
    turn_by_turn.epsilon_y[0] = sig_y**2 / twiss["bety"][0]

    # We loop here now
    for turn in range(1, nturns):
        # ----- Potentially re-compute the elliptic integrals and IBS growth rates ----- #
        if (turn % ibs_step == 0) or (turn == 1):
            print(f"Turn {turn}: re-computing the Nagaitsev integrals and growth rates")
            # We compute from values at the previous turn
            IBS.growth_rates(  # this recomputes the integrals by default
                turn_by_turn.epsilon_x[turn - 1],
                turn_by_turn.epsilon_y[turn - 1],
                turn_by_turn.sig_delta[turn - 1],
                turn_by_turn.bunch_length[turn - 1],
            )

        # ----- Compute the new emittances ----- #
        new_emit_x, new_emit_y, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
            epsx=turn_by_turn.epsilon_x[turn - 1],
            epsy=turn_by_turn.epsilon_y[turn - 1],
            sigma_delta=turn_by_turn.sig_delta[turn - 1],
            bunch_length=turn_by_turn.bunch_length[turn - 1],
            # dt = 1.0 / IBS.optics.revolution_frequency,  # default value
        )

        # ----- Update the records with the new values ----- #
        turn_by_turn.epsilon_x[turn] = new_emit_x
        turn_by_turn.epsilon_y[turn] = new_emit_y
        turn_by_turn.sig_delta[turn] = new_sig_delta
        turn_by_turn.bunch_length[turn] = new_bunch_length





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Turn 1: re-computing the Nagaitsev integrals and growth rates
    Turn 200: re-computing the Nagaitsev integrals and growth rates
    Turn 400: re-computing the Nagaitsev integrals and growth rates
    Turn 600: re-computing the Nagaitsev integrals and growth rates
    Turn 800: re-computing the Nagaitsev integrals and growth rates
    Turn 1000: re-computing the Nagaitsev integrals and growth rates
    Turn 1200: re-computing the Nagaitsev integrals and growth rates
    Turn 1400: re-computing the Nagaitsev integrals and growth rates
    Turn 1600: re-computing the Nagaitsev integrals and growth rates
    Turn 1800: re-computing the Nagaitsev integrals and growth rates
    Turn 2000: re-computing the Nagaitsev integrals and growth rates
    Turn 2200: re-computing the Nagaitsev integrals and growth rates
    Turn 2400: re-computing the Nagaitsev integrals and growth rates
    Turn 2600: re-computing the Nagaitsev integrals and growth rates
    Turn 2800: re-computing the Nagaitsev integrals and growth rates
    Turn 3000: re-computing the Nagaitsev integrals and growth rates
    Turn 3200: re-computing the Nagaitsev integrals and growth rates
    Turn 3400: re-computing the Nagaitsev integrals and growth rates
    Turn 3600: re-computing the Nagaitsev integrals and growth rates
    Turn 3800: re-computing the Nagaitsev integrals and growth rates
    Turn 4000: re-computing the Nagaitsev integrals and growth rates
    Turn 4200: re-computing the Nagaitsev integrals and growth rates
    Turn 4400: re-computing the Nagaitsev integrals and growth rates
    Turn 4600: re-computing the Nagaitsev integrals and growth rates
    Turn 4800: re-computing the Nagaitsev integrals and growth rates
    Turn 5000: re-computing the Nagaitsev integrals and growth rates
    Turn 5200: re-computing the Nagaitsev integrals and growth rates
    Turn 5400: re-computing the Nagaitsev integrals and growth rates
    Turn 5600: re-computing the Nagaitsev integrals and growth rates
    Turn 5800: re-computing the Nagaitsev integrals and growth rates
    Turn 6000: re-computing the Nagaitsev integrals and growth rates
    Turn 6200: re-computing the Nagaitsev integrals and growth rates
    Turn 6400: re-computing the Nagaitsev integrals and growth rates
    Turn 6600: re-computing the Nagaitsev integrals and growth rates
    Turn 6800: re-computing the Nagaitsev integrals and growth rates
    Turn 7000: re-computing the Nagaitsev integrals and growth rates
    Turn 7200: re-computing the Nagaitsev integrals and growth rates
    Turn 7400: re-computing the Nagaitsev integrals and growth rates
    Turn 7600: re-computing the Nagaitsev integrals and growth rates
    Turn 7800: re-computing the Nagaitsev integrals and growth rates
    Turn 8000: re-computing the Nagaitsev integrals and growth rates
    Turn 8200: re-computing the Nagaitsev integrals and growth rates
    Turn 8400: re-computing the Nagaitsev integrals and growth rates
    Turn 8600: re-computing the Nagaitsev integrals and growth rates
    Turn 8800: re-computing the Nagaitsev integrals and growth rates
    Turn 9000: re-computing the Nagaitsev integrals and growth rates
    Turn 9200: re-computing the Nagaitsev integrals and growth rates
    Turn 9400: re-computing the Nagaitsev integrals and growth rates
    Turn 9600: re-computing the Nagaitsev integrals and growth rates
    Turn 9800: re-computing the Nagaitsev integrals and growth rates




.. GENERATED FROM PYTHON SOURCE LINES 235-238

Feel free to run this simulation for more turns, or with a different frequency
of the IBS growth rates re-computation. After this is done running, we can plot
the evolutions across the turns:

.. GENERATED FROM PYTHON SOURCE LINES 238-267

.. code-block:: Python


    fig, axs = plt.subplot_mosaic(
        [["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7)
    )

    axs["epsx"].plot(turns, 1e10 * turn_by_turn.epsilon_x, lw=2)
    axs["epsy"].plot(turns, 1e13 * turn_by_turn.epsilon_y, lw=2)
    axs["sigd"].plot(turns, 1e3 * turn_by_turn.sig_delta, lw=2)
    axs["bl"].plot(turns, 1e3 * turn_by_turn.bunch_length, lw=2)

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$ [$10^{-10}$m]")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$ [$10^{-13}$m]")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$ [$10^{-3}$]")
    axs["bl"].set_ylabel(r"Bunch length [mm]")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Turn Number")

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))

    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 268-275

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~xibs.analytical`: `~.xibs.analytical.NagaitsevIBS`, `~.xibs.analytical.NagaitsevIBS.growth_rates`, `~.xibs.analytical.NagaitsevIBS.integrals`, `~.xibs.analytical.NagaitsevIBS.emittance_evolution`
   - `~xibs.inputs`: `~xibs.inputs.BeamParameters`, `~xibs.inputs.OpticsParameters`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 23.757 seconds)


.. _sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_analytical_nagaitsev_emittances.ipynb <demo_analytical_nagaitsev_emittances.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_analytical_nagaitsev_emittances.py <demo_analytical_nagaitsev_emittances.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
