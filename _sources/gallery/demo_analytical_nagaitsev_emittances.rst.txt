
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_analytical_nagaitsev_emittances.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_analytical_nagaitsev_emittances.py:


.. _demo-analytical-nagaitsev:

=====================================================================
Nagaitsev Formalism - Analytical Growth Rates and Emittance Evolution
=====================================================================

This example shows how to use the `~.xibs.analytical.NagaitsevIBS` class
to calculate IBS growth rates and emittances evolutions analytically.

We will demonstrate using an `xtrack.Line` of the ``CLIC`` damping ring,
for a positron beam.

.. GENERATED FROM PYTHON SOURCE LINES 15-47

.. code-block:: Python

    import logging
    import warnings

    from dataclasses import dataclass

    import matplotlib.pyplot as plt
    import numpy as np
    import xpart as xp
    import xtrack as xt

    from xibs.analytical import NagaitsevIBS
    from xibs.inputs import BeamParameters, OpticsParameters

    warnings.simplefilter("ignore")  # for this tutorial's clarity
    logging.basicConfig(
        level=logging.WARNING,
        format="[%(asctime)s] [%(levelname)s] - %(module)s.%(funcName)s:%(lineno)d - %(message)s",
        datefmt="%H:%M:%S",
    )
    plt.rcParams.update(
        {
            "font.family": "serif",
            "font.size": 20,
            "axes.titlesize": 20,
            "axes.labelsize": 20,
            "xtick.labelsize": 20,
            "ytick.labelsize": 20,
            "legend.fontsize": 15,
            "figure.titlesize": 20,
        }
    )








.. GENERATED FROM PYTHON SOURCE LINES 49-51

Let's start by defining the line and particle information, as well as some
parameters for later use:

.. GENERATED FROM PYTHON SOURCE LINES 51-62

.. code-block:: Python


    line_file = "lines/chrom-corr_DR.newlattice_2GHz.json"
    harmonic_number = 2852
    rf_voltage = 4.5  # in MV
    energy_loss = 0  # let's pretend ;)
    bunch_intensity = 4.4e9
    sigma_z = 1.58e-3
    nemitt_x = 5.6644e-07
    nemitt_y = 3.7033e-09
    n_part = int(5e3)  # for this example let's not use too many particles








.. GENERATED FROM PYTHON SOURCE LINES 63-67

Setting up line and particles
-----------------------------
Let's start by loading the `xtrack.Line`, activating RF cavities and
generating a matched Gaussian bunch:

.. GENERATED FROM PYTHON SOURCE LINES 67-91

.. code-block:: Python


    line = xt.Line.from_json(line_file)
    line.build_tracker(extra_headers=["#define XTRACK_MULTIPOLE_NO_SYNRAD"])

    # ----- Power accelerating cavities ----- #
    cavities = [element for element in line.elements if isinstance(element, xt.Cavity)]
    for cavity in cavities:
        cavity.lag = 180

    p0 = xp.Particles(mass0=xp.ELECTRON_MASS_EV, q0=1, p0c=2.86e9)
    line.particle_ref = p0
    twiss = line.twiss()

    particles = xp.generate_matched_gaussian_bunch(
        num_particles=n_part,
        total_intensity_particles=bunch_intensity,
        nemitt_x=nemitt_x,
        nemitt_y=nemitt_y,
        sigma_z=sigma_z,
        particle_ref=p0,
        line=line,
        engine="single-rf-harmonic",
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading line from dict:   0%|          | 0/71796 [00:00<?, ?it/s]    Loading line from dict:   4%|▍         | 2942/71796 [00:00<00:02, 29408.39it/s]    Loading line from dict:   8%|▊         | 5925/71796 [00:00<00:02, 29654.96it/s]    Loading line from dict:  12%|█▏        | 8906/71796 [00:00<00:02, 29714.76it/s]    Loading line from dict:  17%|█▋        | 11913/71796 [00:00<00:02, 29854.44it/s]    Loading line from dict:  21%|██        | 14922/71796 [00:00<00:01, 29939.10it/s]    Loading line from dict:  25%|██▍       | 17916/71796 [00:00<00:02, 21954.49it/s]    Loading line from dict:  29%|██▉       | 20840/71796 [00:00<00:02, 23866.51it/s]    Loading line from dict:  33%|███▎      | 23766/71796 [00:00<00:01, 25337.40it/s]    Loading line from dict:  37%|███▋      | 26548/71796 [00:01<00:01, 26027.61it/s]    Loading line from dict:  41%|████      | 29284/71796 [00:01<00:01, 25828.79it/s]    Loading line from dict:  45%|████▍     | 31959/71796 [00:01<00:01, 25601.29it/s]    Loading line from dict:  48%|████▊     | 34582/71796 [00:01<00:01, 25395.28it/s]    Loading line from dict:  52%|█████▏    | 37296/71796 [00:01<00:01, 25890.04it/s]    Loading line from dict:  56%|█████▌    | 40260/71796 [00:01<00:01, 26979.36it/s]    Loading line from dict:  60%|██████    | 43224/71796 [00:01<00:01, 27757.43it/s]    Loading line from dict:  64%|██████▍   | 46152/71796 [00:01<00:00, 28201.32it/s]    Loading line from dict:  68%|██████▊   | 49100/71796 [00:01<00:00, 28577.56it/s]    Loading line from dict:  73%|███████▎  | 52084/71796 [00:01<00:00, 28948.62it/s]    Loading line from dict:  77%|███████▋  | 55040/71796 [00:02<00:00, 29123.28it/s]    Loading line from dict:  81%|████████  | 57959/71796 [00:02<00:00, 21541.07it/s]    Loading line from dict:  85%|████████▍ | 60896/71796 [00:02<00:00, 23415.68it/s]    Loading line from dict:  89%|████████▊ | 63576/71796 [00:02<00:00, 24278.91it/s]    Loading line from dict:  92%|█████████▏| 66194/71796 [00:02<00:00, 24506.85it/s]    Loading line from dict:  96%|█████████▌| 68780/71796 [00:02<00:00, 24634.37it/s]    Loading line from dict:  99%|█████████▉| 71339/71796 [00:02<00:00, 24735.48it/s]    Loading line from dict: 100%|██████████| 71796/71796 [00:02<00:00, 25873.07it/s]
    Done loading line from dict.           
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.
    SingleRFHarmonicMatcher: Gaussian parameter is equal to 0.002m to achieve target RMS bunch length (0.002m).
    SingleRFHarmonicMatcher: Transforming distribution: 18%      SingleRFHarmonicMatcher: Transforming distribution: 19%      SingleRFHarmonicMatcher: Transforming distribution: 19%      SingleRFHarmonicMatcher: Transforming distribution: 20%      SingleRFHarmonicMatcher: Transforming distribution: 21%      SingleRFHarmonicMatcher: Transforming distribution: 21%      SingleRFHarmonicMatcher: Transforming distribution: 22%      SingleRFHarmonicMatcher: Transforming distribution: 23%      SingleRFHarmonicMatcher: Transforming distribution: 23%      SingleRFHarmonicMatcher: Transforming distribution: 24%      SingleRFHarmonicMatcher: Transforming distribution: 25%      SingleRFHarmonicMatcher: Transforming distribution: 25%      SingleRFHarmonicMatcher: Transforming distribution: 26%      SingleRFHarmonicMatcher: Transforming distribution: 27%      SingleRFHarmonicMatcher: Transforming distribution: 27%      SingleRFHarmonicMatcher: Transforming distribution: 28%      SingleRFHarmonicMatcher: Transforming distribution: 29%      SingleRFHarmonicMatcher: Transforming distribution: 29%      SingleRFHarmonicMatcher: Transforming distribution: 30%      SingleRFHarmonicMatcher: Transforming distribution: 31%      SingleRFHarmonicMatcher: Transforming distribution: 31%      SingleRFHarmonicMatcher: Transforming distribution: 32%      SingleRFHarmonicMatcher: Transforming distribution: 33%      SingleRFHarmonicMatcher: Transforming distribution: 33%      SingleRFHarmonicMatcher: Transforming distribution: 34%      SingleRFHarmonicMatcher: Transforming distribution: 35%      SingleRFHarmonicMatcher: Transforming distribution: 35%      SingleRFHarmonicMatcher: Transforming distribution: 36%      SingleRFHarmonicMatcher: Transforming distribution: 37%      SingleRFHarmonicMatcher: Transforming distribution: 37%      SingleRFHarmonicMatcher: Transforming distribution: 38%      SingleRFHarmonicMatcher: Transforming distribution: 39%      SingleRFHarmonicMatcher: Transforming distribution: 39%      SingleRFHarmonicMatcher: Transforming distribution: 40%      SingleRFHarmonicMatcher: Transforming distribution: 41%      SingleRFHarmonicMatcher: Transforming distribution: 41%      SingleRFHarmonicMatcher: Transforming distribution: 42%      SingleRFHarmonicMatcher: Transforming distribution: 43%      SingleRFHarmonicMatcher: Transforming distribution: 43%      SingleRFHarmonicMatcher: Transforming distribution: 44%      SingleRFHarmonicMatcher: Transforming distribution: 45%      SingleRFHarmonicMatcher: Transforming distribution: 45%      SingleRFHarmonicMatcher: Transforming distribution: 46%      SingleRFHarmonicMatcher: Transforming distribution: 47%      SingleRFHarmonicMatcher: Transforming distribution: 47%      SingleRFHarmonicMatcher: Transforming distribution: 48%      SingleRFHarmonicMatcher: Transforming distribution: 49%      SingleRFHarmonicMatcher: Transforming distribution: 49%      SingleRFHarmonicMatcher: Transforming distribution: 50%      SingleRFHarmonicMatcher: Transforming distribution: 51%      SingleRFHarmonicMatcher: Transforming distribution: 51%      SingleRFHarmonicMatcher: Transforming distribution: 52%      SingleRFHarmonicMatcher: Transforming distribution: 53%      SingleRFHarmonicMatcher: Transforming distribution: 53%      SingleRFHarmonicMatcher: Transforming distribution: 54%      SingleRFHarmonicMatcher: Transforming distribution: 55%      SingleRFHarmonicMatcher: Transforming distribution: 55%      SingleRFHarmonicMatcher: Transforming distribution: 56%      SingleRFHarmonicMatcher: Transforming distribution: 57%      SingleRFHarmonicMatcher: Transforming distribution: 57%      SingleRFHarmonicMatcher: Transforming distribution: 58%      SingleRFHarmonicMatcher: Transforming distribution: 59%      SingleRFHarmonicMatcher: Transforming distribution: 59%      SingleRFHarmonicMatcher: Transforming distribution: 60%      SingleRFHarmonicMatcher: Transforming distribution: 61%      SingleRFHarmonicMatcher: Transforming distribution: 61%      SingleRFHarmonicMatcher: Transforming distribution: 62%      SingleRFHarmonicMatcher: Transforming distribution: 63%      SingleRFHarmonicMatcher: Transforming distribution: 63%      SingleRFHarmonicMatcher: Transforming distribution: 64%      SingleRFHarmonicMatcher: Transforming distribution: 65%      SingleRFHarmonicMatcher: Transforming distribution: 65%      SingleRFHarmonicMatcher: Transforming distribution: 66%      SingleRFHarmonicMatcher: Transforming distribution: 67%      SingleRFHarmonicMatcher: Transforming distribution: 67%      SingleRFHarmonicMatcher: Transforming distribution: 68%      SingleRFHarmonicMatcher: Transforming distribution: 69%      SingleRFHarmonicMatcher: Transforming distribution: 69%      SingleRFHarmonicMatcher: Transforming distribution: 70%      SingleRFHarmonicMatcher: Transforming distribution: 71%      SingleRFHarmonicMatcher: Transforming distribution: 71%      SingleRFHarmonicMatcher: Transforming distribution: 72%      SingleRFHarmonicMatcher: Transforming distribution: 73%      SingleRFHarmonicMatcher: Transforming distribution: 73%      SingleRFHarmonicMatcher: Transforming distribution: 74%      SingleRFHarmonicMatcher: Transforming distribution: 75%      SingleRFHarmonicMatcher: Transforming distribution: 75%      SingleRFHarmonicMatcher: Transforming distribution: 76%      SingleRFHarmonicMatcher: Transforming distribution: 77%      SingleRFHarmonicMatcher: Transforming distribution: 77%      SingleRFHarmonicMatcher: Transforming distribution: 78%      SingleRFHarmonicMatcher: Transforming distribution: 79%      SingleRFHarmonicMatcher: Transforming distribution: 79%      SingleRFHarmonicMatcher: Transforming distribution: 80%      SingleRFHarmonicMatcher: Transforming distribution: 81%      SingleRFHarmonicMatcher: Transforming distribution: 81%      SingleRFHarmonicMatcher: Transforming distribution: 82%      SingleRFHarmonicMatcher: Transforming distribution: 83%      SingleRFHarmonicMatcher: Transforming distribution: 83%      SingleRFHarmonicMatcher: Transforming distribution: 84%      SingleRFHarmonicMatcher: Transforming distribution: 85%      SingleRFHarmonicMatcher: Transforming distribution: 85%      SingleRFHarmonicMatcher: Transforming distribution: 86%      SingleRFHarmonicMatcher: Transforming distribution: 87%      SingleRFHarmonicMatcher: Transforming distribution: 87%      SingleRFHarmonicMatcher: Transforming distribution: 88%      SingleRFHarmonicMatcher: Transforming distribution: 89%      SingleRFHarmonicMatcher: Transforming distribution: 89%      SingleRFHarmonicMatcher: Transforming distribution: 90%      SingleRFHarmonicMatcher: Transforming distribution: 91%      SingleRFHarmonicMatcher: Transforming distribution: 91%      SingleRFHarmonicMatcher: Transforming distribution: 92%      SingleRFHarmonicMatcher: Transforming distribution: 93%      SingleRFHarmonicMatcher: Transforming distribution: 93%      SingleRFHarmonicMatcher: Transforming distribution: 94%      SingleRFHarmonicMatcher: Transforming distribution: 95%      SingleRFHarmonicMatcher: Transforming distribution: 95%      SingleRFHarmonicMatcher: Transforming distribution: 96%      SingleRFHarmonicMatcher: Transforming distribution: 97%      SingleRFHarmonicMatcher: Transforming distribution: 97%      SingleRFHarmonicMatcher: Transforming distribution: 98%      SingleRFHarmonicMatcher: Transforming distribution: 99%      SingleRFHarmonicMatcher: Transforming distribution: 99%      SingleRFHarmonicMatcher: Done transforming distribution.
    SingleRFHarmonicMatcher: Sampling particles:  1%      SingleRFHarmonicMatcher: Sampling particles:  2%      SingleRFHarmonicMatcher: Sampling particles:  3%      SingleRFHarmonicMatcher: Sampling particles:  4%      SingleRFHarmonicMatcher: Sampling particles:  5%      SingleRFHarmonicMatcher: Sampling particles:  6%      SingleRFHarmonicMatcher: Sampling particles:  6%      SingleRFHarmonicMatcher: Sampling particles:  7%      SingleRFHarmonicMatcher: Sampling particles:  8%      SingleRFHarmonicMatcher: Sampling particles: 10%      SingleRFHarmonicMatcher: Sampling particles: 10%      SingleRFHarmonicMatcher: Sampling particles: 11%      SingleRFHarmonicMatcher: Sampling particles: 12%      SingleRFHarmonicMatcher: Sampling particles: 13%      SingleRFHarmonicMatcher: Sampling particles: 14%      SingleRFHarmonicMatcher: Sampling particles: 15%      SingleRFHarmonicMatcher: Sampling particles: 16%      SingleRFHarmonicMatcher: Sampling particles: 17%      SingleRFHarmonicMatcher: Sampling particles: 19%      SingleRFHarmonicMatcher: Sampling particles: 20%      SingleRFHarmonicMatcher: Sampling particles: 21%      SingleRFHarmonicMatcher: Sampling particles: 21%      SingleRFHarmonicMatcher: Sampling particles: 22%      SingleRFHarmonicMatcher: Sampling particles: 23%      SingleRFHarmonicMatcher: Sampling particles: 24%      SingleRFHarmonicMatcher: Sampling particles: 25%      SingleRFHarmonicMatcher: Sampling particles: 26%      SingleRFHarmonicMatcher: Sampling particles: 27%      SingleRFHarmonicMatcher: Sampling particles: 28%      SingleRFHarmonicMatcher: Sampling particles: 29%      SingleRFHarmonicMatcher: Sampling particles: 30%      SingleRFHarmonicMatcher: Sampling particles: 31%      SingleRFHarmonicMatcher: Sampling particles: 32%      SingleRFHarmonicMatcher: Sampling particles: 33%      SingleRFHarmonicMatcher: Sampling particles: 34%      SingleRFHarmonicMatcher: Sampling particles: 35%      SingleRFHarmonicMatcher: Sampling particles: 36%      SingleRFHarmonicMatcher: Sampling particles: 37%      SingleRFHarmonicMatcher: Sampling particles: 38%      SingleRFHarmonicMatcher: Sampling particles: 39%      SingleRFHarmonicMatcher: Sampling particles: 40%      SingleRFHarmonicMatcher: Sampling particles: 40%      SingleRFHarmonicMatcher: Sampling particles: 41%      SingleRFHarmonicMatcher: Sampling particles: 42%      SingleRFHarmonicMatcher: Sampling particles: 43%      SingleRFHarmonicMatcher: Sampling particles: 44%      SingleRFHarmonicMatcher: Sampling particles: 45%      SingleRFHarmonicMatcher: Sampling particles: 46%      SingleRFHarmonicMatcher: Sampling particles: 47%      SingleRFHarmonicMatcher: Sampling particles: 48%      SingleRFHarmonicMatcher: Sampling particles: 49%      SingleRFHarmonicMatcher: Sampling particles: 50%      SingleRFHarmonicMatcher: Sampling particles: 51%      SingleRFHarmonicMatcher: Sampling particles: 51%      SingleRFHarmonicMatcher: Sampling particles: 52%      SingleRFHarmonicMatcher: Sampling particles: 53%      SingleRFHarmonicMatcher: Sampling particles: 54%      SingleRFHarmonicMatcher: Sampling particles: 55%      SingleRFHarmonicMatcher: Sampling particles: 56%      SingleRFHarmonicMatcher: Sampling particles: 57%      SingleRFHarmonicMatcher: Sampling particles: 58%      SingleRFHarmonicMatcher: Sampling particles: 59%      SingleRFHarmonicMatcher: Sampling particles: 60%      SingleRFHarmonicMatcher: Sampling particles: 61%      SingleRFHarmonicMatcher: Sampling particles: 62%      SingleRFHarmonicMatcher: Sampling particles: 62%      SingleRFHarmonicMatcher: Sampling particles: 63%      SingleRFHarmonicMatcher: Sampling particles: 64%      SingleRFHarmonicMatcher: Sampling particles: 65%      SingleRFHarmonicMatcher: Sampling particles: 66%      SingleRFHarmonicMatcher: Sampling particles: 67%      SingleRFHarmonicMatcher: Sampling particles: 68%      SingleRFHarmonicMatcher: Sampling particles: 69%      SingleRFHarmonicMatcher: Sampling particles: 70%      SingleRFHarmonicMatcher: Sampling particles: 71%      SingleRFHarmonicMatcher: Sampling particles: 72%      SingleRFHarmonicMatcher: Sampling particles: 73%      SingleRFHarmonicMatcher: Sampling particles: 74%      SingleRFHarmonicMatcher: Sampling particles: 75%      SingleRFHarmonicMatcher: Sampling particles: 76%      SingleRFHarmonicMatcher: Sampling particles: 77%      SingleRFHarmonicMatcher: Sampling particles: 78%      SingleRFHarmonicMatcher: Sampling particles: 78%      SingleRFHarmonicMatcher: Sampling particles: 80%      SingleRFHarmonicMatcher: Sampling particles: 80%      SingleRFHarmonicMatcher: Sampling particles: 81%      SingleRFHarmonicMatcher: Sampling particles: 82%      SingleRFHarmonicMatcher: Sampling particles: 84%      SingleRFHarmonicMatcher: Sampling particles: 84%      SingleRFHarmonicMatcher: Sampling particles: 85%      SingleRFHarmonicMatcher: Sampling particles: 86%      SingleRFHarmonicMatcher: Sampling particles: 87%      SingleRFHarmonicMatcher: Sampling particles: 88%      SingleRFHarmonicMatcher: Sampling particles: 89%      SingleRFHarmonicMatcher: Sampling particles: 90%      SingleRFHarmonicMatcher: Sampling particles: 90%      SingleRFHarmonicMatcher: Sampling particles: 92%      SingleRFHarmonicMatcher: Sampling particles: 92%      SingleRFHarmonicMatcher: Sampling particles: 93%      SingleRFHarmonicMatcher: Sampling particles: 94%      SingleRFHarmonicMatcher: Sampling particles: 95%      SingleRFHarmonicMatcher: Sampling particles: 96%      SingleRFHarmonicMatcher: Sampling particles: 97%      SingleRFHarmonicMatcher: Sampling particles: 98%      SingleRFHarmonicMatcher: Sampling particles: 99%      SingleRFHarmonicMatcher: Sampling particles: 100%      SingleRFHarmonicMatcher: Sampling particles: 101%      SingleRFHarmonicMatcher: Sampled 5000 particles




.. GENERATED FROM PYTHON SOURCE LINES 92-94

We can have a look at the generated particles (see the `xsuite user guide
<https://xsuite.readthedocs.io/en/latest/particlesmanip.html>`_ for more)

.. GENERATED FROM PYTHON SOURCE LINES 94-111

.. code-block:: Python


    fig, (axx, axy, axz) = plt.subplots(3, 1, figsize=(9, 11))

    axx.plot(1e6 * particles.x, 1e5 * particles.px, ".", ms=3)
    axy.plot(1e6 * particles.y, 1e6 * particles.py, ".", ms=3)
    axz.plot(1e3 * particles.zeta, 1e3 * particles.delta, ".", ms=3)

    axx.set_xlabel(r"$x$ [$\mu$m]")
    axx.set_ylabel(r"$p_x$ [$10^{-5}$]")
    axy.set_xlabel(r"$y$ [$\mu$m]")
    axy.set_ylabel(r"$p_y$ [$10^{-3}$]")
    axz.set_xlabel(r"$z$ [$10^{-3}$]")
    axz.set_ylabel(r"$\delta$ [$10^{-3}$]")
    fig.align_ylabels([axx, axy, axz])
    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 112-114

We can compute initial (geometrical) emittances as well as the bunch length
from the `xpart.Particles` object:

.. GENERATED FROM PYTHON SOURCE LINES 114-124

.. code-block:: Python


    sig_x = np.std(particles.x[particles.state > 0])  # horizontal stdev
    sig_y = np.std(particles.y[particles.state > 0])  # vertical stdev
    sig_delta = np.std(particles.delta[particles.state > 0])  # momentum spread

    # Compute horizontal & vertical geometric emittances as well as the bunch length, all in [m]
    geom_epsx = (sig_x**2 - (twiss["dx"][0] * sig_delta) ** 2) / twiss["betx"][0]
    geom_epsy = sig_y**2 / twiss["bety"][0]
    bunch_l = np.std(particles.zeta[particles.state > 0])








.. GENERATED FROM PYTHON SOURCE LINES 125-131

Computing Elliptic Integrals and IBS Growth Rates
-------------------------------------------------
Let us instantiate the `~.xibs.analytical.NagaitsevIBS` class. It is fairly
simple and is done from both the beam parameters of the particles and the
optics parameters of the line. For each of these a specific `dataclass`
is provided in the `~.xibs.inputs` module.

.. GENERATED FROM PYTHON SOURCE LINES 131-136

.. code-block:: Python


    beam_params = BeamParameters(particles)
    optics = OpticsParameters(twiss)
    IBS = NagaitsevIBS(beam_params, optics)








.. GENERATED FROM PYTHON SOURCE LINES 137-141

As a first step, all calculations in rely on the computing of Nagaitsev integrals
:cite:p:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`, which is done with
a dedicated function. These are returned, but also stored internally in the **IBS**
object and will be updated internally each time they are computed.

.. GENERATED FROM PYTHON SOURCE LINES 141-146

.. code-block:: Python


    integrals = IBS.integrals(geom_epsx, geom_epsy, sig_delta)
    print(integrals)
    print(IBS.elliptic_integrals)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    NagaitsevIntegrals(Ix=7.727787802829985e+19, Iy=1.4489563812771686e+17, Iz=5.76340827423927e+23)
    NagaitsevIntegrals(Ix=7.727787802829985e+19, Iy=1.4489563812771686e+17, Iz=5.76340827423927e+23)




.. GENERATED FROM PYTHON SOURCE LINES 147-152

From these the **IBS** growth rates can be computed, which is again done by calling
a dedicated function. If the integrals mentioned above have not been computed yet,
an message will be logged for the user and they will be computed first. Once again,
these are returned but also stored internally and updated internally each time they
are computed.

.. GENERATED FROM PYTHON SOURCE LINES 152-157

.. code-block:: Python


    growth_rates = IBS.growth_rates(geom_epsx, geom_epsy, sig_delta, bunch_l)
    print(growth_rates)
    print(IBS.ibs_growth_rates)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    IBSGrowthRates(Tx=351.4178736756964, Ty=102.8766871727001, Tz=82.1087410232501)
    IBSGrowthRates(Tx=351.4178736756964, Ty=102.8766871727001, Tz=82.1087410232501)




.. GENERATED FROM PYTHON SOURCE LINES 158-162

Please note that the `IBS.growth_rates` method by default re-computes the
integrals before computing the growth rates. This convenient as usually, one
needs to update the integrals when they want to update the growth rates. It
can be disabled by setting the `compute_integrals` argument to `False`.

.. GENERATED FROM PYTHON SOURCE LINES 164-169

Computing New Emittances from Growth Rates
------------------------------------------
From these one can compute the emittances at the next time step. For the emittances
at the next turn, once should use :math:`1 / f_{rev}` as the time step, which
is the default value used if it is not provided.

.. GENERATED FROM PYTHON SOURCE LINES 169-178

.. code-block:: Python


    new_geom_epsx, new_geom_epsy, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
        geom_epsx, geom_epsy, sig_delta, bunch_l
    )
    print(f"Next time step geometrical epsilon_x = {new_geom_epsx} m")
    print(f"Next time step geometrical epsilon_y = {new_geom_epsy} m")
    print(f"Next time step sigma_delta = {new_sig_delta}")
    print(f"Next time step bunch length = {new_bunch_length} m")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Next time step geometrical epsilon_x = 1.0202295529495647e-10 m
    Next time step geometrical epsilon_y = 6.532072224024142e-13 m
    Next time step sigma_delta = 0.0018042423971649205
    Next time step bunch length = 0.00157198000465576 m




.. GENERATED FROM PYTHON SOURCE LINES 179-186

Analytical Evolution for Many Turns
-----------------------------------
One can then analytically look at the evolution through many turns by looping
over this calculation. Let's do this for 10 000 turns, re-computing the elliptic
integrals and the IBS growth rates every 200 turns. The more frequent this update
the more physically accurate the results will be, but the longer the simulation
as this computation is the most compute-intensive process.

.. GENERATED FROM PYTHON SOURCE LINES 186-245

.. code-block:: Python


    nturns = 10_000  # number of turns to loop for
    ibs_step = 200  # frequency at which to re-compute the growth rates in [turns]
    turns = np.arange(nturns, dtype=int)  # array of turns


    # Set up a dataclass to store the results
    @dataclass
    class Records:
        """Dataclass to store (and update) important values through tracking."""

        epsilon_x: np.ndarray
        epsilon_y: np.ndarray
        sig_delta: np.ndarray
        bunch_length: np.ndarray


    # Initialize the dataclass
    turn_by_turn = Records(
        epsilon_x=np.zeros(nturns, dtype=float),
        epsilon_y=np.zeros(nturns, dtype=float),
        sig_delta=np.zeros(nturns, dtype=float),
        bunch_length=np.zeros(nturns, dtype=float),
    )

    # Store the initial values
    turn_by_turn.bunch_length[0] = np.std(particles.zeta[particles.state > 0])
    turn_by_turn.sig_delta[0] = sig_delta
    turn_by_turn.epsilon_x[0] = (sig_x**2 - (twiss["dx"][0] * sig_delta) ** 2) / twiss["betx"][0]
    turn_by_turn.epsilon_y[0] = (sig_y**2 - (twiss["dy"][0] * sig_delta) ** 2) / twiss["bety"][0]

    # We loop here now
    for turn in range(1, nturns):
        # ----- Potentially re-compute the elliptic integrals and IBS growth rates ----- #
        if (turn % ibs_step == 0) or (turn == 1):
            print(f"Turn {turn}: re-computing the Nagaitsev integrals and growth rates")
            # We compute from values at the previous turn
            IBS.growth_rates(  # this recomputes the integrals by default
                turn_by_turn.epsilon_x[turn - 1],
                turn_by_turn.epsilon_y[turn - 1],
                turn_by_turn.sig_delta[turn - 1],
                turn_by_turn.bunch_length[turn - 1],
            )

        # ----- Compute the new emittances ----- #
        new_emit_x, new_emit_y, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
            epsx=turn_by_turn.epsilon_x[turn - 1],
            epsy=turn_by_turn.epsilon_y[turn - 1],
            sigma_delta=turn_by_turn.sig_delta[turn - 1],
            bunch_length=turn_by_turn.bunch_length[turn - 1],
            # dt = 1.0 / IBS.optics.revolution_frequency,  # default value
        )

        # ----- Update the records with the new values ----- #
        turn_by_turn.epsilon_x[turn] = new_emit_x
        turn_by_turn.epsilon_y[turn] = new_emit_y
        turn_by_turn.sig_delta[turn] = new_sig_delta
        turn_by_turn.bunch_length[turn] = new_bunch_length





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Turn 1: re-computing the Nagaitsev integrals and growth rates
    Turn 200: re-computing the Nagaitsev integrals and growth rates
    Turn 400: re-computing the Nagaitsev integrals and growth rates
    Turn 600: re-computing the Nagaitsev integrals and growth rates
    Turn 800: re-computing the Nagaitsev integrals and growth rates
    Turn 1000: re-computing the Nagaitsev integrals and growth rates
    Turn 1200: re-computing the Nagaitsev integrals and growth rates
    Turn 1400: re-computing the Nagaitsev integrals and growth rates
    Turn 1600: re-computing the Nagaitsev integrals and growth rates
    Turn 1800: re-computing the Nagaitsev integrals and growth rates
    Turn 2000: re-computing the Nagaitsev integrals and growth rates
    Turn 2200: re-computing the Nagaitsev integrals and growth rates
    Turn 2400: re-computing the Nagaitsev integrals and growth rates
    Turn 2600: re-computing the Nagaitsev integrals and growth rates
    Turn 2800: re-computing the Nagaitsev integrals and growth rates
    Turn 3000: re-computing the Nagaitsev integrals and growth rates
    Turn 3200: re-computing the Nagaitsev integrals and growth rates
    Turn 3400: re-computing the Nagaitsev integrals and growth rates
    Turn 3600: re-computing the Nagaitsev integrals and growth rates
    Turn 3800: re-computing the Nagaitsev integrals and growth rates
    Turn 4000: re-computing the Nagaitsev integrals and growth rates
    Turn 4200: re-computing the Nagaitsev integrals and growth rates
    Turn 4400: re-computing the Nagaitsev integrals and growth rates
    Turn 4600: re-computing the Nagaitsev integrals and growth rates
    Turn 4800: re-computing the Nagaitsev integrals and growth rates
    Turn 5000: re-computing the Nagaitsev integrals and growth rates
    Turn 5200: re-computing the Nagaitsev integrals and growth rates
    Turn 5400: re-computing the Nagaitsev integrals and growth rates
    Turn 5600: re-computing the Nagaitsev integrals and growth rates
    Turn 5800: re-computing the Nagaitsev integrals and growth rates
    Turn 6000: re-computing the Nagaitsev integrals and growth rates
    Turn 6200: re-computing the Nagaitsev integrals and growth rates
    Turn 6400: re-computing the Nagaitsev integrals and growth rates
    Turn 6600: re-computing the Nagaitsev integrals and growth rates
    Turn 6800: re-computing the Nagaitsev integrals and growth rates
    Turn 7000: re-computing the Nagaitsev integrals and growth rates
    Turn 7200: re-computing the Nagaitsev integrals and growth rates
    Turn 7400: re-computing the Nagaitsev integrals and growth rates
    Turn 7600: re-computing the Nagaitsev integrals and growth rates
    Turn 7800: re-computing the Nagaitsev integrals and growth rates
    Turn 8000: re-computing the Nagaitsev integrals and growth rates
    Turn 8200: re-computing the Nagaitsev integrals and growth rates
    Turn 8400: re-computing the Nagaitsev integrals and growth rates
    Turn 8600: re-computing the Nagaitsev integrals and growth rates
    Turn 8800: re-computing the Nagaitsev integrals and growth rates
    Turn 9000: re-computing the Nagaitsev integrals and growth rates
    Turn 9200: re-computing the Nagaitsev integrals and growth rates
    Turn 9400: re-computing the Nagaitsev integrals and growth rates
    Turn 9600: re-computing the Nagaitsev integrals and growth rates
    Turn 9800: re-computing the Nagaitsev integrals and growth rates




.. GENERATED FROM PYTHON SOURCE LINES 246-249

Feel free to run this simulation for more turns, or with a different frequency
of the IBS growth rates re-computation. After this is done running, we can plot
the evolutions across the turns:

.. GENERATED FROM PYTHON SOURCE LINES 249-276

.. code-block:: Python


    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    axs["epsx"].plot(turns, 1e10 * turn_by_turn.epsilon_x, lw=2)
    axs["epsy"].plot(turns, 1e13 * turn_by_turn.epsilon_y, lw=2)
    axs["sigd"].plot(turns, 1e3 * turn_by_turn.sig_delta, lw=2)
    axs["bl"].plot(turns, 1e3 * turn_by_turn.bunch_length, lw=2)

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$ [$10^{-10}$m]")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$ [$10^{-13}$m]")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$ [$10^{-3}$]")
    axs["bl"].set_ylabel(r"Bunch length [mm]")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Turn Number")

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))

    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 277-284

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~xibs.analytical`: `~.xibs.analytical.NagaitsevIBS`, `~.xibs.analytical.NagaitsevIBS.growth_rates`, `~.xibs.analytical.NagaitsevIBS.integrals`, `~.xibs.analytical.NagaitsevIBS.emittance_evolution`
   - `~xibs.inputs`: `~xibs.inputs.BeamParameters`, `~xibs.inputs.OpticsParameters`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 37.661 seconds)


.. _sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_analytical_nagaitsev_emittances.ipynb <demo_analytical_nagaitsev_emittances.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_analytical_nagaitsev_emittances.py <demo_analytical_nagaitsev_emittances.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
