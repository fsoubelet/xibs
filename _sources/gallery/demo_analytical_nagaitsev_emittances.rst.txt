
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_analytical_nagaitsev_emittances.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_analytical_nagaitsev_emittances.py:


.. _demo-analytical-nagaitsev:

=====================================================================
Nagaitsev Formalism - Analytical Growth Rates and Emittance Evolution
=====================================================================

This example shows how to use the `~.xibs.analytical.NagaitsevIBS` class
to calculate IBS growth rates and emittances evolutions analytically.

We will demonstrate using an `xtrack.Line` of the ``CLIC`` damping ring,
for a positron beam.

.. GENERATED FROM PYTHON SOURCE LINES 15-48

.. code-block:: Python

    import logging
    import warnings

    from dataclasses import dataclass

    import matplotlib.pyplot as plt
    import numpy as np
    import xpart as xp
    import xtrack as xt

    from xibs.analytical import NagaitsevIBS
    from xibs.formulary import _bunch_length, _geom_epsx, _geom_epsy, _sigma_delta
    from xibs.inputs import BeamParameters, OpticsParameters

    warnings.simplefilter("ignore")  # for this tutorial's clarity
    logging.basicConfig(
        level=logging.WARNING,
        format="[%(asctime)s] [%(levelname)s] - %(module)s.%(funcName)s:%(lineno)d - %(message)s",
        datefmt="%H:%M:%S",
    )
    plt.rcParams.update(
        {
            "font.family": "serif",
            "font.size": 20,
            "axes.titlesize": 20,
            "axes.labelsize": 20,
            "xtick.labelsize": 20,
            "ytick.labelsize": 20,
            "legend.fontsize": 15,
            "figure.titlesize": 20,
        }
    )








.. GENERATED FROM PYTHON SOURCE LINES 50-52

Let's start by defining the line and particle information, as well as some
parameters for later use:

.. GENERATED FROM PYTHON SOURCE LINES 52-60

.. code-block:: Python


    line_file = "lines/chrom-corr_DR.newlattice_2GHz.json"
    bunch_intensity = 4.4e9
    sigma_z = 1.58e-3
    nemitt_x = 5.6644e-07
    nemitt_y = 3.7033e-09
    n_part = int(5e3)  # for this example let's not use too many particles








.. GENERATED FROM PYTHON SOURCE LINES 61-65

Setting up line and particles
-----------------------------
Let's start by loading the `xtrack.Line`, activating RF cavities and
generating a matched Gaussian bunch:

.. GENERATED FROM PYTHON SOURCE LINES 65-88

.. code-block:: Python


    line = xt.Line.from_json(line_file)
    line.build_tracker(extra_headers=["#define XTRACK_MULTIPOLE_NO_SYNRAD"])

    # ----- Power accelerating cavities ----- #
    cavities = [element for element in line.elements if isinstance(element, xt.Cavity)]
    for cavity in cavities:
        cavity.lag = 180

    p0 = xp.Particles(mass0=xp.ELECTRON_MASS_EV, q0=1, p0c=2.86e9)
    line.particle_ref = p0
    twiss = line.twiss()

    particles = xp.generate_matched_gaussian_bunch(
        num_particles=n_part,
        total_intensity_particles=bunch_intensity,
        nemitt_x=nemitt_x,
        nemitt_y=nemitt_y,
        sigma_z=sigma_z,
        particle_ref=p0,
        line=line,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading line from dict:   0%|          | 0/71796 [00:00<?, ?it/s]    Loading line from dict:   4%|▍         | 2978/71796 [00:00<00:02, 29752.51it/s]    Loading line from dict:   8%|▊         | 6026/71796 [00:00<00:02, 30179.75it/s]    Loading line from dict:  13%|█▎        | 9051/71796 [00:00<00:02, 30209.56it/s]    Loading line from dict:  17%|█▋        | 12086/71796 [00:00<00:01, 30253.14it/s]    Loading line from dict:  21%|██        | 15155/71796 [00:00<00:01, 30409.68it/s]    Loading line from dict:  25%|██▌       | 18196/71796 [00:00<00:02, 22797.81it/s]    Loading line from dict:  30%|██▉       | 21242/71796 [00:00<00:02, 24836.97it/s]    Loading line from dict:  34%|███▍      | 24301/71796 [00:00<00:01, 26424.17it/s]    Loading line from dict:  38%|███▊      | 27187/71796 [00:00<00:01, 27107.94it/s]    Loading line from dict:  42%|████▏     | 30022/71796 [00:01<00:01, 26690.41it/s]    Loading line from dict:  46%|████▌     | 32777/71796 [00:01<00:01, 26447.67it/s]    Loading line from dict:  49%|████▉     | 35481/71796 [00:01<00:01, 26208.45it/s]    Loading line from dict:  54%|█████▎    | 38448/71796 [00:01<00:01, 27196.14it/s]    Loading line from dict:  58%|█████▊    | 41508/71796 [00:01<00:01, 28182.79it/s]    Loading line from dict:  62%|██████▏   | 44553/71796 [00:01<00:00, 28847.33it/s]    Loading line from dict:  66%|██████▋   | 47612/71796 [00:01<00:00, 29351.04it/s]    Loading line from dict:  71%|███████   | 50660/71796 [00:01<00:00, 29685.42it/s]    Loading line from dict:  75%|███████▍  | 53709/71796 [00:01<00:00, 29923.80it/s]    Loading line from dict:  79%|███████▉  | 56710/71796 [00:02<00:00, 22326.52it/s]    Loading line from dict:  83%|████████▎ | 59744/71796 [00:02<00:00, 24258.44it/s]    Loading line from dict:  87%|████████▋ | 62683/71796 [00:02<00:00, 25566.14it/s]    Loading line from dict:  91%|█████████ | 65436/71796 [00:02<00:00, 25588.35it/s]    Loading line from dict:  95%|█████████▍| 68133/71796 [00:02<00:00, 25636.11it/s]    Loading line from dict:  99%|█████████▊| 70794/71796 [00:02<00:00, 25647.29it/s]    Loading line from dict: 100%|██████████| 71796/71796 [00:02<00:00, 26686.70it/s]
    Done loading line from dict.           
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 89-91

We can have a look at the generated particles (see the `xsuite user guide
<https://xsuite.readthedocs.io/en/latest/particlesmanip.html>`_ for more)

.. GENERATED FROM PYTHON SOURCE LINES 91-108

.. code-block:: Python


    fig, (axx, axy, axz) = plt.subplots(3, 1, figsize=(9, 11))

    axx.plot(1e6 * particles.x, 1e5 * particles.px, ".", ms=3)
    axy.plot(1e6 * particles.y, 1e6 * particles.py, ".", ms=3)
    axz.plot(1e3 * particles.zeta, 1e3 * particles.delta, ".", ms=3)

    axx.set_xlabel(r"$x$ [$\mu$m]")
    axx.set_ylabel(r"$p_x$ [$10^{-5}$]")
    axy.set_xlabel(r"$y$ [$\mu$m]")
    axy.set_ylabel(r"$p_y$ [$10^{-3}$]")
    axz.set_xlabel(r"$z$ [$10^{-3}$]")
    axz.set_ylabel(r"$\delta$ [$10^{-3}$]")
    fig.align_ylabels([axx, axy, axz])
    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_001_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 109-111

We can compute initial (geometrical) emittances as well as the bunch length
from the `xtrack.Particles` object:

.. GENERATED FROM PYTHON SOURCE LINES 111-117

.. code-block:: Python


    geom_epsx = _geom_epsx(particles, twiss.betx[0], twiss.dx[0])
    geom_epsy = _geom_epsy(particles, twiss.bety[0], twiss.dy[0])
    bunch_l = _bunch_length(particles)
    sig_delta = _sigma_delta(particles)








.. GENERATED FROM PYTHON SOURCE LINES 118-124

Computing Elliptic Integrals and IBS Growth Rates
-------------------------------------------------
Let us instantiate the `~.xibs.analytical.NagaitsevIBS` class. It is fairly
simple and is done from both the beam parameters of the particles and the
optics parameters of the line. For each of these a specific `dataclass`
is provided in the `~.xibs.inputs` module.

.. GENERATED FROM PYTHON SOURCE LINES 124-129

.. code-block:: Python


    beam_params = BeamParameters(particles)
    optics = OpticsParameters(twiss)
    IBS = NagaitsevIBS(beam_params, optics)








.. GENERATED FROM PYTHON SOURCE LINES 130-134

As a first step, all calculations in rely on the computing of Nagaitsev integrals
:cite:p:`PRAB:Nagaitsev:IBS_formulas_fast_numerical_evaluation`, which is done with
a dedicated function. These are returned, but also stored internally in the **IBS**
object and will be updated internally each time they are computed.

.. GENERATED FROM PYTHON SOURCE LINES 134-139

.. code-block:: Python


    integrals = IBS.integrals(geom_epsx, geom_epsy, sig_delta)
    print(integrals)
    print(IBS.elliptic_integrals)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    NagaitsevIntegrals(Ix=8.011247932350923e+19, Iy=1.4688106453659462e+17, Iz=5.949384625668466e+23)
    NagaitsevIntegrals(Ix=8.011247932350923e+19, Iy=1.4688106453659462e+17, Iz=5.949384625668466e+23)




.. GENERATED FROM PYTHON SOURCE LINES 140-145

From these the **IBS** growth rates can be computed, which is again done by calling
a dedicated function. If the integrals mentioned above have not been computed yet,
an message will be logged for the user and they will be computed first. Once again,
these are returned but also stored internally and updated internally each time they
are computed.

.. GENERATED FROM PYTHON SOURCE LINES 145-150

.. code-block:: Python


    growth_rates = IBS.growth_rates(geom_epsx, geom_epsy, sig_delta, bunch_l)
    print(growth_rates)
    print(IBS.ibs_growth_rates)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    IBSGrowthRates(Tx=363.65502673683744, Ty=102.15884776920952, Tz=89.95281094337176)
    IBSGrowthRates(Tx=363.65502673683744, Ty=102.15884776920952, Tz=89.95281094337176)




.. GENERATED FROM PYTHON SOURCE LINES 151-155

**Please note** that the `IBS.growth_rates` method by default re-computes the
integrals before computing the growth rates. This is convenient as usually,
one needs to update the integrals when they want to update the growth rates.
It can be disabled by setting the `compute_integrals` argument to `False`.

.. GENERATED FROM PYTHON SOURCE LINES 157-162

Computing New Emittances from Growth Rates
------------------------------------------
From these one can compute the emittances at the next time step. For the emittances
at the next turn, once should use :math:`1 / f_{rev}` as the time step, which
is the default value used if it is not provided.

.. GENERATED FROM PYTHON SOURCE LINES 162-171

.. code-block:: Python


    new_geom_epsx, new_geom_epsy, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
        geom_epsx, geom_epsy, sig_delta, bunch_l
    )
    print(f"Next time step geometrical epsilon_x = {new_geom_epsx} m")
    print(f"Next time step geometrical epsilon_y = {new_geom_epsy} m")
    print(f"Next time step sigma_delta = {new_sig_delta}")
    print(f"Next time step bunch length = {new_bunch_length} m")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Next time step geometrical epsilon_x = 1.0079509664715099e-10 m
    Next time step geometrical epsilon_y = 6.575922854905154e-13 m
    Next time step sigma_delta = 0.0017392351995013347
    Next time step bunch length = 0.0015914539580582203 m




.. GENERATED FROM PYTHON SOURCE LINES 172-179

Analytical Evolution for Many Turns
-----------------------------------
One can then analytically look at the evolution through many turns by looping
over this calculation. Let's do this for 10 000 turns, re-computing the elliptic
integrals and the IBS growth rates every 200 turns. The more frequent this update
the more physically accurate the results will be, but the longer the simulation
as this computation is the most compute-intensive process.

.. GENERATED FROM PYTHON SOURCE LINES 179-244

.. code-block:: Python


    nturns = 10_000  # number of turns to loop for
    ibs_step = 200  # frequency at which to re-compute the growth rates in [turns]
    turns = np.arange(nturns, dtype=int)  # array of turns


    # Set up a dataclass to store the results
    @dataclass
    class Records:
        """Dataclass to store (and update) important values through tracking."""

        epsilon_x: np.ndarray  # geometric horizontal emittance in [m]
        epsilon_y: np.ndarray  # geometric vertical emittance in [m]
        sig_delta: np.ndarray  # momentum spread
        bunch_length: np.ndarray  # bunch length in [m]

        @classmethod
        def init_zeroes(cls, n_turns: int):
            return cls(
                epsilon_x=np.zeros(n_turns, dtype=float),
                epsilon_y=np.zeros(n_turns, dtype=float),
                sig_delta=np.zeros(n_turns, dtype=float),
                bunch_length=np.zeros(n_turns, dtype=float),
            )

        def update_at_turn(self, turn: int, epsx: float, epsy: float, sigd: float, bl: float):
            """Works for turns / seconds, just needs the correct index to store in."""
            self.epsilon_x[turn] = epsx
            self.epsilon_y[turn] = epsy
            self.sig_delta[turn] = sigd
            self.bunch_length[turn] = bl


    # Initialize the dataclass & store the initial values
    turn_by_turn = Records.init_zeroes(nturns)
    turn_by_turn.update_at_turn(0, geom_epsx, geom_epsy, sig_delta, bunch_l)


    # ----- We loop here now ----- # 

    for turn in range(1, nturns):
        # ----- Potentially re-compute the elliptic integrals and IBS growth rates ----- #
        if (turn % ibs_step == 0) or (turn == 1):
            print(f"Turn {turn}: re-computing the Nagaitsev integrals and growth rates")
            # We compute from values at the previous turn
            IBS.growth_rates(  # this recomputes the integrals by default
                turn_by_turn.epsilon_x[turn - 1],
                turn_by_turn.epsilon_y[turn - 1],
                turn_by_turn.sig_delta[turn - 1],
                turn_by_turn.bunch_length[turn - 1],
            )

        # ----- Compute the new emittances ----- #
        new_emit_x, new_emit_y, new_sig_delta, new_bunch_length = IBS.emittance_evolution(
            epsx=turn_by_turn.epsilon_x[turn - 1],
            epsy=turn_by_turn.epsilon_y[turn - 1],
            sigma_delta=turn_by_turn.sig_delta[turn - 1],
            bunch_length=turn_by_turn.bunch_length[turn - 1],
            # dt = 1.0 / IBS.optics.revolution_frequency,  # default value
        )

        # ----- Update the records with the new values ----- #
        turn_by_turn.update_at_turn(turn, new_emit_x, new_emit_y, new_sig_delta, new_bunch_length)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Turn 1: re-computing the Nagaitsev integrals and growth rates
    Turn 200: re-computing the Nagaitsev integrals and growth rates
    Turn 400: re-computing the Nagaitsev integrals and growth rates
    Turn 600: re-computing the Nagaitsev integrals and growth rates
    Turn 800: re-computing the Nagaitsev integrals and growth rates
    Turn 1000: re-computing the Nagaitsev integrals and growth rates
    Turn 1200: re-computing the Nagaitsev integrals and growth rates
    Turn 1400: re-computing the Nagaitsev integrals and growth rates
    Turn 1600: re-computing the Nagaitsev integrals and growth rates
    Turn 1800: re-computing the Nagaitsev integrals and growth rates
    Turn 2000: re-computing the Nagaitsev integrals and growth rates
    Turn 2200: re-computing the Nagaitsev integrals and growth rates
    Turn 2400: re-computing the Nagaitsev integrals and growth rates
    Turn 2600: re-computing the Nagaitsev integrals and growth rates
    Turn 2800: re-computing the Nagaitsev integrals and growth rates
    Turn 3000: re-computing the Nagaitsev integrals and growth rates
    Turn 3200: re-computing the Nagaitsev integrals and growth rates
    Turn 3400: re-computing the Nagaitsev integrals and growth rates
    Turn 3600: re-computing the Nagaitsev integrals and growth rates
    Turn 3800: re-computing the Nagaitsev integrals and growth rates
    Turn 4000: re-computing the Nagaitsev integrals and growth rates
    Turn 4200: re-computing the Nagaitsev integrals and growth rates
    Turn 4400: re-computing the Nagaitsev integrals and growth rates
    Turn 4600: re-computing the Nagaitsev integrals and growth rates
    Turn 4800: re-computing the Nagaitsev integrals and growth rates
    Turn 5000: re-computing the Nagaitsev integrals and growth rates
    Turn 5200: re-computing the Nagaitsev integrals and growth rates
    Turn 5400: re-computing the Nagaitsev integrals and growth rates
    Turn 5600: re-computing the Nagaitsev integrals and growth rates
    Turn 5800: re-computing the Nagaitsev integrals and growth rates
    Turn 6000: re-computing the Nagaitsev integrals and growth rates
    Turn 6200: re-computing the Nagaitsev integrals and growth rates
    Turn 6400: re-computing the Nagaitsev integrals and growth rates
    Turn 6600: re-computing the Nagaitsev integrals and growth rates
    Turn 6800: re-computing the Nagaitsev integrals and growth rates
    Turn 7000: re-computing the Nagaitsev integrals and growth rates
    Turn 7200: re-computing the Nagaitsev integrals and growth rates
    Turn 7400: re-computing the Nagaitsev integrals and growth rates
    Turn 7600: re-computing the Nagaitsev integrals and growth rates
    Turn 7800: re-computing the Nagaitsev integrals and growth rates
    Turn 8000: re-computing the Nagaitsev integrals and growth rates
    Turn 8200: re-computing the Nagaitsev integrals and growth rates
    Turn 8400: re-computing the Nagaitsev integrals and growth rates
    Turn 8600: re-computing the Nagaitsev integrals and growth rates
    Turn 8800: re-computing the Nagaitsev integrals and growth rates
    Turn 9000: re-computing the Nagaitsev integrals and growth rates
    Turn 9200: re-computing the Nagaitsev integrals and growth rates
    Turn 9400: re-computing the Nagaitsev integrals and growth rates
    Turn 9600: re-computing the Nagaitsev integrals and growth rates
    Turn 9800: re-computing the Nagaitsev integrals and growth rates




.. GENERATED FROM PYTHON SOURCE LINES 245-248

Feel free to run this simulation for more turns, or with a different frequency
of the IBS growth rates re-computation. After this is done running, we can plot
the evolutions across the turns:

.. GENERATED FROM PYTHON SOURCE LINES 248-275

.. code-block:: Python


    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    axs["epsx"].plot(turns, 1e10 * turn_by_turn.epsilon_x, lw=2)
    axs["epsy"].plot(turns, 1e13 * turn_by_turn.epsilon_y, lw=2)
    axs["sigd"].plot(turns, 1e3 * turn_by_turn.sig_delta, lw=2)
    axs["bl"].plot(turns, 1e3 * turn_by_turn.bunch_length, lw=2)

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$ [$10^{-10}$m]")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$ [$10^{-13}$m]")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$ [$10^{-3}$]")
    axs["bl"].set_ylabel(r"Bunch length [mm]")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Turn Number")

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))

    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg
   :alt: demo analytical nagaitsev emittances
   :srcset: /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002.svg, /gallery/images/sphx_glr_demo_analytical_nagaitsev_emittances_002_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 276-283

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~xibs.analytical`: `~.xibs.analytical.NagaitsevIBS`, `~.xibs.analytical.NagaitsevIBS.growth_rates`, `~.xibs.analytical.NagaitsevIBS.integrals`, `~.xibs.analytical.NagaitsevIBS.emittance_evolution`
   - `~xibs.inputs`: `~xibs.inputs.BeamParameters`, `~xibs.inputs.OpticsParameters`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 23.741 seconds)


.. _sphx_glr_download_gallery_demo_analytical_nagaitsev_emittances.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_analytical_nagaitsev_emittances.ipynb <demo_analytical_nagaitsev_emittances.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_analytical_nagaitsev_emittances.py <demo_analytical_nagaitsev_emittances.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
