
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_kicks_auto_recompute_coefficients.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_demo_kicks_auto_recompute_coefficients.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_kicks_auto_recompute_coefficients.py:


.. _demo-kicks-auto-coefficients:

==========================================
Automatic Kick Coefficients Re-Computation
==========================================

This example shows how to use the the auto recomputing functionality for kick
coefficients in the kick classes. To follow this example please first have a
look at the :ref:`Kinetic Kicks example <demo-kinetic-kicks>` as well as the
relevant :ref:`FAQ section <xibs-faq-auto-recompute-kick-coefficients>`.

This script will showcase the functionality by following an identical flow to the 
Kinetic kicks example linked above and expanding on the relevant parts. Demonstration
will be done using the CLIC Damping Ring line.

.. GENERATED FROM PYTHON SOURCE LINES 18-52

.. code-block:: Python

    import logging
    from dataclasses import dataclass
    from typing import Self

    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import xobjects as xo
    import xpart as xp
    import xtrack as xt

    from xibs.formulary import _bunch_length, _geom_epsx, _geom_epsy, _percent_change, _sigma_delta
    from xibs.inputs import BeamParameters, OpticsParameters
    from xibs.kicks import KineticKickIBS

    logging.basicConfig(
        level=logging.WARNING,
        format="[%(asctime)s] [%(levelname)s] - %(module)s.%(funcName)s:%(lineno)d - %(message)s",
        datefmt="%H:%M:%S",
    )
    plt.rcParams.update(
        {
            "font.family": "serif",
            "font.size": 20,
            "axes.titlesize": 20,
            "axes.labelsize": 20,
            "xtick.labelsize": 20,
            "ytick.labelsize": 20,
            "legend.fontsize": 15,
            "figure.titlesize": 20,
        }
    )









.. GENERATED FROM PYTHON SOURCE LINES 54-59

Let's start by defining the line and particle information, as well as some
parameters for later use. Note that `bunch_intensity` is the actual number
of particles in the bunch, and its value influences the IBS kick coefficients
calculation while `n_part` is the number of generated particles for
tracking, which is much lower.

.. GENERATED FROM PYTHON SOURCE LINES 59-68

.. code-block:: Python


    line_file = "lines/chrom-corr_DR.newlattice_2GHz.json"
    bunch_intensity = int(4.5e9)
    n_part = int(1.5e3)
    sigma_z = 1.5e-3
    nemitt_x = 5.5e-7
    nemitt_y = 3.5e-9









.. GENERATED FROM PYTHON SOURCE LINES 69-74

Setting up line and particles
-----------------------------
Let's now load the line from file, activate the accelerating cavities and
create a context for multithreading with OpenMP, since tracking particles
is going to take some time:

.. GENERATED FROM PYTHON SOURCE LINES 74-98

.. code-block:: Python


    line = xt.Line.from_json(line_file)
    context = xo.ContextCpu(omp_num_threads="auto")
    line.particle_ref = xp.Particles(mass0=xp.ELECTRON_MASS_EV, q0=1, p0c=2.86e9)

    # ----- Power accelerating cavities ----- #
    for cavity in [element for element in line.elements if isinstance(element, xt.Cavity)]:
        cavity.lag = 180  # we are above transition

    line.build_tracker(context, extra_headers=["#define XTRACK_MULTIPOLE_NO_SYNRAD"])
    line.optimize_for_tracking()
    twiss = line.twiss()

    particles = xp.generate_matched_gaussian_bunch(
        num_particles=n_part,
        total_intensity_particles=bunch_intensity,
        nemitt_x=nemitt_x,
        nemitt_y=nemitt_y,
        sigma_z=sigma_z,
        line=line,
    )
    particles2 = particles.copy()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading line from dict:   0%|          | 0/71796 [00:00<?, ?it/s]    Loading line from dict:   4%|▍         | 2860/71796 [00:00<00:02, 28597.85it/s]    Loading line from dict:   8%|▊         | 5766/71796 [00:00<00:02, 28866.47it/s]    Loading line from dict:  12%|█▏        | 8670/71796 [00:00<00:02, 28944.39it/s]    Loading line from dict:  16%|█▌        | 11620/71796 [00:00<00:02, 29161.81it/s]    Loading line from dict:  20%|██        | 14537/71796 [00:00<00:02, 21468.05it/s]    Loading line from dict:  24%|██▍       | 17438/71796 [00:00<00:02, 23537.85it/s]    Loading line from dict:  28%|██▊       | 20358/71796 [00:00<00:02, 25131.58it/s]    Loading line from dict:  32%|███▏      | 23250/71796 [00:00<00:01, 26218.76it/s]    Loading line from dict:  36%|███▋      | 26198/71796 [00:00<00:01, 27157.81it/s]    Loading line from dict:  40%|████      | 29008/71796 [00:01<00:01, 26403.83it/s]    Loading line from dict:  44%|████▍     | 31716/71796 [00:01<00:01, 25721.93it/s]    Loading line from dict:  48%|████▊     | 34336/71796 [00:01<00:01, 25287.92it/s]    Loading line from dict:  52%|█████▏    | 36988/71796 [00:01<00:01, 25637.63it/s]    Loading line from dict:  56%|█████▌    | 39934/71796 [00:01<00:01, 26735.68it/s]    Loading line from dict:  60%|█████▉    | 42868/71796 [00:01<00:01, 27493.77it/s]    Loading line from dict:  64%|██████▍   | 45776/71796 [00:01<00:00, 27950.67it/s]    Loading line from dict:  68%|██████▊   | 48703/71796 [00:01<00:00, 28340.77it/s]    Loading line from dict:  72%|███████▏  | 51648/71796 [00:01<00:00, 28665.58it/s]    Loading line from dict:  76%|███████▌  | 54523/71796 [00:02<00:00, 21379.41it/s]    Loading line from dict:  80%|███████▉  | 57427/71796 [00:02<00:00, 23223.48it/s]    Loading line from dict:  84%|████████▍ | 60348/71796 [00:02<00:00, 24753.43it/s]    Loading line from dict:  88%|████████▊ | 63101/71796 [00:02<00:00, 25490.88it/s]    Loading line from dict:  92%|█████████▏| 65794/71796 [00:02<00:00, 24635.49it/s]    Loading line from dict:  95%|█████████▌| 68362/71796 [00:02<00:00, 24513.50it/s]    Loading line from dict:  99%|█████████▊| 70886/71796 [00:02<00:00, 24622.87it/s]    Loading line from dict: 100%|██████████| 71796/71796 [00:02<00:00, 25547.32it/s]
    Done loading line from dict.           
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.
    Disable xdeps expressions
    Remove markers
    Remove inactive multipoles
    Merge consecutive multipoles
    Remove redundant apertures
    Remove zero length drifts
    Merge consecutive drifts
    Use simple bends
    Use simple quadrupoles
    Rebuild tracker data
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 99-101

We can compute initial (geometrical) emittances as well as the bunch length
from the `xtrack.Particles` object:

.. GENERATED FROM PYTHON SOURCE LINES 101-108

.. code-block:: Python


    geom_epsx = _geom_epsx(particles, twiss.betx[0], twiss.dx[0])
    geom_epsy = _geom_epsy(particles, twiss.bety[0], twiss.dy[0])
    bunch_l = _bunch_length(particles)
    sig_delta = _sigma_delta(particles)









.. GENERATED FROM PYTHON SOURCE LINES 109-113

Generating the IBS Kick Class
-----------------------------
Just as all user-facing classes in ``xibs``, the `KineticKickIBS` :cite:`NuclInstr:Zenkevich:Kinetic_IBS`
class is instantiated by providing a `BeamParameters` and an `OpticsParameters` objects:

.. GENERATED FROM PYTHON SOURCE LINES 113-123

.. code-block:: Python


    beamparams = BeamParameters.from_line(line, n_part=bunch_intensity)
    opticsparams = OpticsParameters.from_line(line)

    # This is the threshold that would trigger the auto-recomping of the growth rates.
    AUTO_PERCENT = 8  # threshold: 8% change from kick application
    IBS = KineticKickIBS(beamparams, opticsparams)
    AUTO_IBS = KineticKickIBS(beamparams, opticsparams, auto_recompute_coefficients_percent=AUTO_PERCENT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 124-128

Computing and Applying IBS Kicks
--------------------------------
The so-called "kick coefficients" are computed directly from the particle distribution
by calling the dedicated method. They correspond to the diffusion minus friction terms.

.. GENERATED FROM PYTHON SOURCE LINES 128-132

.. code-block:: Python


    IBS.compute_kick_coefficients(particles2)
    AUTO_IBS.compute_kick_coefficients(particles2)








.. GENERATED FROM PYTHON SOURCE LINES 133-136

Let's see the evolution of the transverse emittances, :math:`\sigma_{\delta}`
and bunch length from a kick. We can have a look at the relative change of
the particles's distribution properties from before to after.

.. GENERATED FROM PYTHON SOURCE LINES 136-153

.. code-block:: Python


    IBS.apply_ibs_kick(particles2)
    new_geom_epsx = _geom_epsx(particles2, twiss.betx[0], twiss.dx[0])
    new_geom_epsy = _geom_epsy(particles2, twiss.bety[0], twiss.dy[0])
    new_sig_delta = _sigma_delta(particles2)
    new_bunch_length = _bunch_length(particles2)

    # Let's see the relative change
    print(f"Geom. epsx: {geom_epsx:.2e} -> {new_geom_epsx:.2e} | ({100 * _percent_change(geom_epsx, new_geom_epsx):.2e}% change)")
    print(f"Geom. epsy: {geom_epsy:.2e} -> {new_geom_epsy:.2e} | ({100 * _percent_change(geom_epsy, new_geom_epsy):.2e}% change)")
    print(f"Sigma delta: {sig_delta:.2e} -> {new_sig_delta:.2e} | ({100 * _percent_change(sig_delta, new_sig_delta):.2e}% change)")
    print(f"Bunch length: {bunch_l:.4e} -> {new_bunch_length:.4e} | ({100 * _percent_change(bunch_l, new_bunch_length):.2e}% change)")

    # Let's reset these
    particles2 = particles.copy()  






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Geom. epsx: 9.76e-11 -> 9.76e-11 | (1.33e-06% change)
    Geom. epsy: 5.90e-13 -> 5.90e-13 | (0.00e+00% change)
    Sigma delta: 1.65e-03 -> 1.65e-03 | (-6.61e-01% change)
    Bunch length: 1.5459e-03 -> 1.5459e-03 | (0.00e+00% change)




.. GENERATED FROM PYTHON SOURCE LINES 154-158

Preparing for the Tracking Simulation
-------------------------------------
We will loop over turns for 1000 turns, and compare results from the regular
and auto-recomputing scenarios. Let's set up the utilities needed for this:

.. GENERATED FROM PYTHON SOURCE LINES 158-199

.. code-block:: Python


    nturns = 1000  # number of turns to loop for
    ibs_step = 50  # frequency at which to re-compute coefficients in [turns]
    turns = np.linspace(0, nturns, nturns, dtype=int)  # array of tracked turns


    # Set up a dataclass to store the results
    @dataclass
    class Records:
        epsilon_x: np.ndarray
        epsilon_y: np.ndarray
        sigma_delta: np.ndarray
        bunch_length: np.ndarray

        def update_at_turn(self, turn: int, parts: xp.Particles, twiss: xt.TwissTable):
            self.epsilon_x[turn] = _geom_epsx(parts, twiss.betx[0], twiss.dx[0])
            self.epsilon_y[turn] = _geom_epsy(parts, twiss.bety[0], twiss.dy[0])
            self.sigma_delta[turn] = _sigma_delta(parts)
            self.bunch_length[turn] = _bunch_length(parts)

        @classmethod
        def init_zeroes(cls, n_turns: int) -> Self:  # noqa: F821
            return cls(
                epsilon_x=np.zeros(n_turns, dtype=float),
                epsilon_y=np.zeros(n_turns, dtype=float),
                sigma_delta=np.zeros(n_turns, dtype=float),
                bunch_length=np.zeros(n_turns, dtype=float),
            )


    # Initialize the dataclass & store the initial values
    regular = Records.init_zeroes(nturns)
    regular.update_at_turn(0, particles, twiss)

    auto = Records.init_zeroes(nturns)
    auto.update_at_turn(0, particles, twiss)

    # These arrays we will use to see when the auto-recomputing kicks in
    auto_recomputes = np.zeros(nturns, dtype=float)
    fixed_recomputes = np.zeros(nturns, dtype=float)








.. GENERATED FROM PYTHON SOURCE LINES 200-203

Tracking Evolution Over Turns
-----------------------------
Let's now loop and let the auto-recomputing do its job.

.. GENERATED FROM PYTHON SOURCE LINES 203-240

.. code-block:: Python


    for turn in range(1, nturns):
        # This is not necessary, just for showcasing in this tutorial
        n_recomputes_for_auto = AUTO_IBS._number_of_coefficients_computations

        # ----- Potentially re-compute the IBS kick coefficients ----- #
        if (turn % ibs_step == 0) or (turn == 1):
            print(f"Turn {turn:d}: Fixed interval re-computing of coefficients")
            # Below always re-computes the coefficients every 'ibs_step' turns
            IBS.compute_kick_coefficients(particles)

        # ----- Manually Apply IBS Kick and Track Turn ----- #
        IBS.apply_ibs_kick(particles)
        AUTO_IBS.apply_ibs_kick(particles2)  # auto-recomputes if necessary
        line.track(particles, num_turns=1)
        line.track(particles2, num_turns=1)

        # ----- Update records for tracked particles ----- #
        regular.update_at_turn(turn, particles, twiss)
        auto.update_at_turn(turn, particles2, twiss)

        # ----- Check if the rates were auto-recomputed ----- #
        # This is also not necessary, just for showcasing in this tutorial
        if AUTO_IBS._number_of_coefficients_computations > n_recomputes_for_auto:
            print(f"At turn {turn} - Auto re-computed coefficients")
            auto_recomputes[turn - 1] = 1


    # Here we also aggregate the fixed recomputes
    for turn in turns:
        if (turn % ibs_step == 0) or (turn == 1):
            fixed_recomputes[turn - 1] = 1

    # And these are simply 1D arrays of the turns at which re-computing happened
    where_auto_recomputes = np.flatnonzero(auto_recomputes)
    where_fixed_recomputes = np.flatnonzero(fixed_recomputes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Turn 1: Fixed interval re-computing of coefficients
    At turn 2 - Auto re-computed coefficients
    At turn 8 - Auto re-computed coefficients
    At turn 10 - Auto re-computed coefficients
    At turn 12 - Auto re-computed coefficients
    At turn 22 - Auto re-computed coefficients
    At turn 26 - Auto re-computed coefficients
    At turn 30 - Auto re-computed coefficients
    At turn 36 - Auto re-computed coefficients
    At turn 39 - Auto re-computed coefficients
    At turn 40 - Auto re-computed coefficients
    At turn 42 - Auto re-computed coefficients
    Turn 50: Fixed interval re-computing of coefficients
    At turn 50 - Auto re-computed coefficients
    At turn 53 - Auto re-computed coefficients
    At turn 67 - Auto re-computed coefficients
    At turn 69 - Auto re-computed coefficients
    At turn 79 - Auto re-computed coefficients
    At turn 85 - Auto re-computed coefficients
    At turn 94 - Auto re-computed coefficients
    Turn 100: Fixed interval re-computing of coefficients
    At turn 101 - Auto re-computed coefficients
    At turn 102 - Auto re-computed coefficients
    At turn 108 - Auto re-computed coefficients
    At turn 112 - Auto re-computed coefficients
    At turn 114 - Auto re-computed coefficients
    At turn 120 - Auto re-computed coefficients
    At turn 122 - Auto re-computed coefficients
    At turn 141 - Auto re-computed coefficients
    At turn 146 - Auto re-computed coefficients
    At turn 147 - Auto re-computed coefficients
    At turn 149 - Auto re-computed coefficients
    Turn 150: Fixed interval re-computing of coefficients
    At turn 161 - Auto re-computed coefficients
    At turn 163 - Auto re-computed coefficients
    At turn 170 - Auto re-computed coefficients
    At turn 172 - Auto re-computed coefficients
    At turn 188 - Auto re-computed coefficients
    At turn 190 - Auto re-computed coefficients
    Turn 200: Fixed interval re-computing of coefficients
    At turn 230 - Auto re-computed coefficients
    At turn 242 - Auto re-computed coefficients
    Turn 250: Fixed interval re-computing of coefficients
    At turn 252 - Auto re-computed coefficients
    At turn 263 - Auto re-computed coefficients
    At turn 264 - Auto re-computed coefficients
    At turn 268 - Auto re-computed coefficients
    At turn 280 - Auto re-computed coefficients
    At turn 287 - Auto re-computed coefficients
    At turn 298 - Auto re-computed coefficients
    Turn 300: Fixed interval re-computing of coefficients
    At turn 301 - Auto re-computed coefficients
    At turn 303 - Auto re-computed coefficients
    At turn 304 - Auto re-computed coefficients
    At turn 307 - Auto re-computed coefficients
    At turn 318 - Auto re-computed coefficients
    At turn 320 - Auto re-computed coefficients
    At turn 323 - Auto re-computed coefficients
    At turn 335 - Auto re-computed coefficients
    At turn 339 - Auto re-computed coefficients
    At turn 340 - Auto re-computed coefficients
    At turn 342 - Auto re-computed coefficients
    At turn 343 - Auto re-computed coefficients
    At turn 347 - Auto re-computed coefficients
    Turn 350: Fixed interval re-computing of coefficients
    At turn 357 - Auto re-computed coefficients
    At turn 370 - Auto re-computed coefficients
    At turn 376 - Auto re-computed coefficients
    At turn 382 - Auto re-computed coefficients
    At turn 388 - Auto re-computed coefficients
    Turn 400: Fixed interval re-computing of coefficients
    At turn 400 - Auto re-computed coefficients
    At turn 401 - Auto re-computed coefficients
    At turn 406 - Auto re-computed coefficients
    At turn 408 - Auto re-computed coefficients
    At turn 427 - Auto re-computed coefficients
    At turn 445 - Auto re-computed coefficients
    At turn 447 - Auto re-computed coefficients
    Turn 450: Fixed interval re-computing of coefficients
    At turn 475 - Auto re-computed coefficients
    At turn 487 - Auto re-computed coefficients
    At turn 488 - Auto re-computed coefficients
    At turn 491 - Auto re-computed coefficients
    Turn 500: Fixed interval re-computing of coefficients
    At turn 500 - Auto re-computed coefficients
    At turn 508 - Auto re-computed coefficients
    At turn 524 - Auto re-computed coefficients
    At turn 526 - Auto re-computed coefficients
    At turn 534 - Auto re-computed coefficients
    Turn 550: Fixed interval re-computing of coefficients
    At turn 562 - Auto re-computed coefficients
    At turn 572 - Auto re-computed coefficients
    At turn 598 - Auto re-computed coefficients
    Turn 600: Fixed interval re-computing of coefficients
    At turn 605 - Auto re-computed coefficients
    At turn 608 - Auto re-computed coefficients
    At turn 613 - Auto re-computed coefficients
    At turn 621 - Auto re-computed coefficients
    At turn 626 - Auto re-computed coefficients
    At turn 628 - Auto re-computed coefficients
    At turn 638 - Auto re-computed coefficients
    At turn 644 - Auto re-computed coefficients
    Turn 650: Fixed interval re-computing of coefficients
    At turn 663 - Auto re-computed coefficients
    At turn 669 - Auto re-computed coefficients
    At turn 670 - Auto re-computed coefficients
    At turn 681 - Auto re-computed coefficients
    At turn 686 - Auto re-computed coefficients
    Turn 700: Fixed interval re-computing of coefficients
    At turn 709 - Auto re-computed coefficients
    At turn 712 - Auto re-computed coefficients
    At turn 716 - Auto re-computed coefficients
    At turn 733 - Auto re-computed coefficients
    Turn 750: Fixed interval re-computing of coefficients
    At turn 758 - Auto re-computed coefficients
    At turn 772 - Auto re-computed coefficients
    At turn 773 - Auto re-computed coefficients
    At turn 786 - Auto re-computed coefficients
    At turn 792 - Auto re-computed coefficients
    At turn 793 - Auto re-computed coefficients
    Turn 800: Fixed interval re-computing of coefficients
    At turn 803 - Auto re-computed coefficients
    At turn 840 - Auto re-computed coefficients
    At turn 847 - Auto re-computed coefficients
    At turn 848 - Auto re-computed coefficients
    Turn 850: Fixed interval re-computing of coefficients
    At turn 858 - Auto re-computed coefficients
    At turn 864 - Auto re-computed coefficients
    At turn 885 - Auto re-computed coefficients
    At turn 897 - Auto re-computed coefficients
    Turn 900: Fixed interval re-computing of coefficients
    At turn 904 - Auto re-computed coefficients
    At turn 934 - Auto re-computed coefficients
    Turn 950: Fixed interval re-computing of coefficients
    At turn 951 - Auto re-computed coefficients
    At turn 954 - Auto re-computed coefficients




.. GENERATED FROM PYTHON SOURCE LINES 241-242

Let's see how many recomputes happened in total for each scenario:

.. GENERATED FROM PYTHON SOURCE LINES 242-246

.. code-block:: Python


    print(f"Fixed re-computes: {IBS._number_of_coefficients_computations}")
    print(f"Auto re-computes: {AUTO_IBS._number_of_coefficients_computations}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Fixed re-computes: 21
    Auto re-computes: 117




.. GENERATED FROM PYTHON SOURCE LINES 247-250

That's almost four times as many updates of the coeffifients that were deemed
necessary by the auto-recomputing mechanism. Let's see the effect it has had
on our results by having a look at the evolution of emittances over time:

.. GENERATED FROM PYTHON SOURCE LINES 250-297

.. code-block:: Python


    AVG_TURNS = 3  # for rolling average plotting
    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    # We will add vertical lines at the times where recomputing of the kick 
    # coefficients happened (do this first so they show up in the background)
    for axis in axs.values():
        for turn in where_fixed_recomputes:
            axis.axvline(turn, color="gray", linestyle="--", lw=1, alpha=0.7)
        for turn in where_auto_recomputes:
            axis.axvline(turn, color="C1", linestyle="-", alpha=0.2)

    axs["epsx"].plot(turns, 1e10 * pd.Series(regular.epsilon_x).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["epsy"].plot(turns, 1e13 * pd.Series(regular.epsilon_y).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["sigd"].plot(turns, 1e3 * pd.Series(regular.sigma_delta).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["bl"].plot(turns, 1e3 * pd.Series(regular.bunch_length).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")

    axs["epsx"].plot(turns, 1e10 * pd.Series(auto.epsilon_x).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["epsy"].plot(turns, 1e13 * pd.Series(auto.epsilon_y).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["sigd"].plot(turns, 1e3 * pd.Series(auto.sigma_delta).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["bl"].plot(turns, 1e3 * pd.Series(auto.bunch_length).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$ [$10^{-10}$m]")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$ [$10^{-13}$m]")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$ [$10^{-3}$]")
    axs["bl"].set_ylabel(r"Bunch length [mm]")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Turn Number")

    for axis in axs.values():
        axis.yaxis.set_major_locator(plt.MaxNLocator(3))

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))
    fig.suptitle(f"Evolution of Emittances in CLIC DR (Kinetic Kicks)\nAverage of Last {AVG_TURNS} Turns")

    plt.legend(title="Recompute Coefficients")
    plt.tight_layout()
    plt.show()





.. image-sg:: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001.svg
   :alt: Evolution of Emittances in CLIC DR (Kinetic Kicks) Average of Last 3 Turns
   :srcset: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001.svg, /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 298-299

We can have a look at the relative change from turn to turn:

.. GENERATED FROM PYTHON SOURCE LINES 299-347

.. code-block:: Python


    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    # We will add vertical lines at the times where recomputing of the kick 
    # coefficients happened (do this first so they show up in the background)
    for axis in axs.values():
        for turn in where_fixed_recomputes:
            axis.axvline(turn, color="gray", linestyle="--", lw=1, alpha=0.7)
        for turn in where_auto_recomputes:
            axis.axvline(turn, color="C1", linestyle="-", alpha=0.2)

    axs["epsx"].plot(turns, 1e2 * pd.Series(regular.epsilon_x).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["epsy"].plot(turns, 1e2 * pd.Series(regular.epsilon_y).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["sigd"].plot(turns, 1e2 * pd.Series(regular.sigma_delta).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["bl"].plot(turns, 1e2 * pd.Series(regular.bunch_length).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")

    axs["epsx"].plot(turns, 1e2 * pd.Series(auto.epsilon_x).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["epsy"].plot(turns, 1e2 * pd.Series(auto.epsilon_y).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["sigd"].plot(turns, 1e2 * pd.Series(auto.sigma_delta).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["bl"].plot(turns, 1e2 * pd.Series(auto.bunch_length).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$")
    axs["bl"].set_ylabel(r"Bunch length")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Duration [h]")

    for axis in axs.values():
        axis.axhline(AUTO_PERCENT, color="black", linestyle="--", alpha=0.5, label="Recompute Threshold")
        axis.yaxis.set_major_locator(plt.MaxNLocator(3))
        axis.set_yscale("log")

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))
    fig.suptitle("Percent change from previous turn")

    plt.legend(title="Recompute Coefficients")
    plt.tight_layout()
    plt.show()





.. image-sg:: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002.svg
   :alt: Percent change from previous turn
   :srcset: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002.svg, /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 348-353

We can see that the auto-recompute feature leads to correct results of the IBS
effects in addition to making the tracking loop simpler to write. It also avoids
for the user to have to determine a proper interval for re-computing the kicks -
which could be correct for part of the simulation but not all of it - by adapting
itself to the actual changes in the particle distribution.

.. GENERATED FROM PYTHON SOURCE LINES 356-364

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~xibs.analytical`: `~.xibs.analytical.NagaitsevIBS`, `~.xibs.analytical.NagaitsevIBS.growth_rates`, `~.xibs.analytical.NagaitsevIBS.emittance_evolution`
   - `~xibs.inputs`: `~xibs.inputs.BeamParameters`, `~xibs.inputs.OpticsParameters`
   - `~xibs.kicks`: `~.xibs.kicks.DiffusionCoefficients`, `~.xibs.kicks.FrictionCoefficients`, `~.xibs.kicks.IBSKickCoefficients`, `~.xibs.kicks.KineticKickIBS`, `~.xibs.kicks.KineticKickIBS.apply_ibs_kick`, `~.xibs.kicks.KineticKickIBS.compute_kick_coefficients`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (4 minutes 41.499 seconds)


.. _sphx_glr_download_gallery_demo_kicks_auto_recompute_coefficients.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_kicks_auto_recompute_coefficients.ipynb <demo_kicks_auto_recompute_coefficients.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_kicks_auto_recompute_coefficients.py <demo_kicks_auto_recompute_coefficients.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
