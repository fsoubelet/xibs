
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_kicks_auto_recompute_coefficients.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_demo_kicks_auto_recompute_coefficients.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_kicks_auto_recompute_coefficients.py:


.. _demo-kicks-auto-coefficients:

==========================================
Automatic Kick Coefficients Re-Computation
==========================================

This example shows how to use the the auto recomputing functionality for kick
coefficients in the kick classes. To follow this example please first have a
look at the :ref:`Kinetic Kicks example <demo-kinetic-kicks>` as well as the
relevant :ref:`FAQ section <xibs-faq-auto-recompute-kick-coefficients>`.

This script will showcase the functionality by following an identical flow to the 
Kinetic kicks example linked above and expanding on the relevant parts. Demonstration
will be done using the CLIC Damping Ring line.

.. GENERATED FROM PYTHON SOURCE LINES 18-52

.. code-block:: Python

    import logging
    from dataclasses import dataclass
    from typing import Self

    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import xobjects as xo
    import xpart as xp
    import xtrack as xt

    from xibs.formulary import _bunch_length, _geom_epsx, _geom_epsy, _percent_change, _sigma_delta
    from xibs.inputs import BeamParameters, OpticsParameters
    from xibs.kicks import KineticKickIBS

    logging.basicConfig(
        level=logging.WARNING,
        format="[%(asctime)s] [%(levelname)s] - %(module)s.%(funcName)s:%(lineno)d - %(message)s",
        datefmt="%H:%M:%S",
    )
    plt.rcParams.update(
        {
            "font.family": "serif",
            "font.size": 20,
            "axes.titlesize": 20,
            "axes.labelsize": 20,
            "xtick.labelsize": 20,
            "ytick.labelsize": 20,
            "legend.fontsize": 15,
            "figure.titlesize": 20,
        }
    )









.. GENERATED FROM PYTHON SOURCE LINES 54-59

Let's start by defining the line and particle information, as well as some
parameters for later use. Note that `bunch_intensity` is the actual number
of particles in the bunch, and its value influences the IBS kick coefficients
calculation while `n_part` is the number of generated particles for
tracking, which is much lower.

.. GENERATED FROM PYTHON SOURCE LINES 59-68

.. code-block:: Python


    line_file = "lines/chrom-corr_DR.newlattice_2GHz.json"
    bunch_intensity = int(4.5e9)
    n_part = int(1.5e3)
    sigma_z = 1.5e-3
    nemitt_x = 5.5e-7
    nemitt_y = 3.5e-9









.. GENERATED FROM PYTHON SOURCE LINES 69-74

Setting up line and particles
-----------------------------
Let's now load the line from file, activate the accelerating cavities and
create a context for multithreading with OpenMP, since tracking particles
is going to take some time:

.. GENERATED FROM PYTHON SOURCE LINES 74-98

.. code-block:: Python


    line = xt.Line.from_json(line_file)
    context = xo.ContextCpu(omp_num_threads="auto")
    line.particle_ref = xp.Particles(mass0=xp.ELECTRON_MASS_EV, q0=1, p0c=2.86e9)

    # ----- Power accelerating cavities ----- #
    for cavity in [element for element in line.elements if isinstance(element, xt.Cavity)]:
        cavity.lag = 180  # we are above transition

    line.build_tracker(context, extra_headers=["#define XTRACK_MULTIPOLE_NO_SYNRAD"])
    line.optimize_for_tracking()
    twiss = line.twiss()

    particles = xp.generate_matched_gaussian_bunch(
        num_particles=n_part,
        total_intensity_particles=bunch_intensity,
        nemitt_x=nemitt_x,
        nemitt_y=nemitt_y,
        sigma_z=sigma_z,
        line=line,
    )
    particles2 = particles.copy()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading line from dict:   0%|          | 0/71796 [00:00<?, ?it/s]    Loading line from dict:   4%|▍         | 2918/71796 [00:00<00:02, 29138.76it/s]    Loading line from dict:   8%|▊         | 5874/71796 [00:00<00:02, 29384.40it/s]    Loading line from dict:  12%|█▏        | 8862/71796 [00:00<00:02, 29607.61it/s]    Loading line from dict:  16%|█▋        | 11834/71796 [00:00<00:02, 29645.37it/s]    Loading line from dict:  21%|██        | 14799/71796 [00:00<00:02, 23272.64it/s]    Loading line from dict:  25%|██▍       | 17768/71796 [00:00<00:02, 25119.88it/s]    Loading line from dict:  29%|██▉       | 20738/71796 [00:00<00:01, 26449.04it/s]    Loading line from dict:  33%|███▎      | 23714/71796 [00:00<00:01, 27421.33it/s]    Loading line from dict:  37%|███▋      | 26638/71796 [00:00<00:01, 27955.14it/s]    Loading line from dict:  41%|████      | 29497/71796 [00:01<00:01, 27138.83it/s]    Loading line from dict:  45%|████▍     | 32259/71796 [00:01<00:01, 26611.84it/s]    Loading line from dict:  49%|████▊     | 34954/71796 [00:01<00:01, 26282.33it/s]    Loading line from dict:  53%|█████▎    | 37785/71796 [00:01<00:01, 26865.87it/s]    Loading line from dict:  57%|█████▋    | 40780/71796 [00:01<00:01, 27764.98it/s]    Loading line from dict:  61%|██████    | 43748/71796 [00:01<00:00, 28323.45it/s]    Loading line from dict:  65%|██████▌   | 46736/71796 [00:01<00:00, 28782.83it/s]    Loading line from dict:  69%|██████▉   | 49697/71796 [00:01<00:00, 29027.76it/s]    Loading line from dict:  73%|███████▎  | 52607/71796 [00:01<00:00, 22647.58it/s]    Loading line from dict:  77%|███████▋  | 55583/71796 [00:02<00:00, 24419.21it/s]    Loading line from dict:  82%|████████▏ | 58556/71796 [00:02<00:00, 25812.53it/s]    Loading line from dict:  86%|████████▌ | 61551/71796 [00:02<00:00, 26939.99it/s]    Loading line from dict:  90%|████████▉ | 64364/71796 [00:02<00:00, 26718.77it/s]    Loading line from dict:  93%|█████████▎| 67119/71796 [00:02<00:00, 26297.04it/s]    Loading line from dict:  97%|█████████▋| 69807/71796 [00:02<00:00, 26023.17it/s]    Loading line from dict: 100%|██████████| 71796/71796 [00:02<00:00, 26596.73it/s]
    Done loading line from dict.           
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.
    Disable xdeps expressions
    Remove markers
    Remove inactive multipoles
    Merge consecutive multipoles
    Remove redundant apertures
    Remove zero length drifts
    Merge consecutive drifts
    Use simple bends
    Use simple quadrupoles
    Rebuild tracker data
    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 99-101

We can compute initial (geometrical) emittances as well as the bunch length
from the `xtrack.Particles` object:

.. GENERATED FROM PYTHON SOURCE LINES 101-108

.. code-block:: Python


    geom_epsx = _geom_epsx(particles, twiss.betx[0], twiss.dx[0])
    geom_epsy = _geom_epsy(particles, twiss.bety[0], twiss.dy[0])
    bunch_l = _bunch_length(particles)
    sig_delta = _sigma_delta(particles)









.. GENERATED FROM PYTHON SOURCE LINES 109-113

Generating the IBS Kick Class
-----------------------------
Just as all user-facing classes in ``xibs``, the `KineticKickIBS` :cite:`NuclInstr:Zenkevich:Kinetic_IBS`
class is instantiated by providing a `BeamParameters` and an `OpticsParameters` objects:

.. GENERATED FROM PYTHON SOURCE LINES 113-123

.. code-block:: Python


    beamparams = BeamParameters.from_line(line, n_part=bunch_intensity)
    opticsparams = OpticsParameters.from_line(line)

    # This is the threshold that would trigger the auto-recomping of the growth rates.
    AUTO_PERCENT = 8  # threshold: 8% change from kick application
    IBS = KineticKickIBS(beamparams, opticsparams)
    AUTO_IBS = KineticKickIBS(beamparams, opticsparams, auto_recompute_coefficients_percent=AUTO_PERCENT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Compiling ContextCpu kernels...
    Done compiling ContextCpu kernels.




.. GENERATED FROM PYTHON SOURCE LINES 124-128

Computing and Applying IBS Kicks
--------------------------------
The so-called "kick coefficients" are computed directly from the particle distribution
by calling the dedicated method. They correspond to the diffusion minus friction terms.

.. GENERATED FROM PYTHON SOURCE LINES 128-132

.. code-block:: Python


    IBS.compute_kick_coefficients(particles2)
    AUTO_IBS.compute_kick_coefficients(particles2)








.. GENERATED FROM PYTHON SOURCE LINES 133-136

Let's see the evolution of the transverse emittances, :math:`\sigma_{\delta}`
and bunch length from a kick. We can have a look at the relative change of
the particles's distribution properties from before to after.

.. GENERATED FROM PYTHON SOURCE LINES 136-153

.. code-block:: Python


    IBS.apply_ibs_kick(particles2)
    new_geom_epsx = _geom_epsx(particles2, twiss.betx[0], twiss.dx[0])
    new_geom_epsy = _geom_epsy(particles2, twiss.bety[0], twiss.dy[0])
    new_sig_delta = _sigma_delta(particles2)
    new_bunch_length = _bunch_length(particles2)

    # Let's see the relative change
    print(f"Geom. epsx: {geom_epsx:.2e} -> {new_geom_epsx:.2e} | ({100 * _percent_change(geom_epsx, new_geom_epsx):.2e}% change)")
    print(f"Geom. epsy: {geom_epsy:.2e} -> {new_geom_epsy:.2e} | ({100 * _percent_change(geom_epsy, new_geom_epsy):.2e}% change)")
    print(f"Sigma delta: {sig_delta:.2e} -> {new_sig_delta:.2e} | ({100 * _percent_change(sig_delta, new_sig_delta):.2e}% change)")
    print(f"Bunch length: {bunch_l:.4e} -> {new_bunch_length:.4e} | ({100 * _percent_change(bunch_l, new_bunch_length):.2e}% change)")

    # Let's reset these
    particles2 = particles.copy()  






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Geom. epsx: 9.67e-11 -> 9.67e-11 | (7.06e-06% change)
    Geom. epsy: 5.96e-13 -> 5.96e-13 | (0.00e+00% change)
    Sigma delta: 1.71e-03 -> 1.71e-03 | (-3.27e+00% change)
    Bunch length: 1.4925e-03 -> 1.4925e-03 | (0.00e+00% change)




.. GENERATED FROM PYTHON SOURCE LINES 154-158

Preparing for the Tracking Simulation
-------------------------------------
We will loop over turns for 1000 turns, and compare results from the regular
and auto-recomputing scenarios. Let's set up the utilities needed for this:

.. GENERATED FROM PYTHON SOURCE LINES 158-199

.. code-block:: Python


    nturns = 1000  # number of turns to loop for
    ibs_step = 50  # frequency at which to re-compute coefficients in [turns]
    turns = np.linspace(0, nturns, nturns, dtype=int)  # array of tracked turns


    # Set up a dataclass to store the results
    @dataclass
    class Records:
        epsilon_x: np.ndarray
        epsilon_y: np.ndarray
        sigma_delta: np.ndarray
        bunch_length: np.ndarray

        def update_at_turn(self, turn: int, parts: xp.Particles, twiss: xt.TwissTable):
            self.epsilon_x[turn] = _geom_epsx(parts, twiss.betx[0], twiss.dx[0])
            self.epsilon_y[turn] = _geom_epsy(parts, twiss.bety[0], twiss.dy[0])
            self.sigma_delta[turn] = _sigma_delta(parts)
            self.bunch_length[turn] = _bunch_length(parts)

        @classmethod
        def init_zeroes(cls, n_turns: int) -> Self:  # noqa: F821
            return cls(
                epsilon_x=np.zeros(n_turns, dtype=float),
                epsilon_y=np.zeros(n_turns, dtype=float),
                sigma_delta=np.zeros(n_turns, dtype=float),
                bunch_length=np.zeros(n_turns, dtype=float),
            )


    # Initialize the dataclass & store the initial values
    regular = Records.init_zeroes(nturns)
    regular.update_at_turn(0, particles, twiss)

    auto = Records.init_zeroes(nturns)
    auto.update_at_turn(0, particles, twiss)

    # These arrays we will use to see when the auto-recomputing kicks in
    auto_recomputes = np.zeros(nturns, dtype=float)
    fixed_recomputes = np.zeros(nturns, dtype=float)








.. GENERATED FROM PYTHON SOURCE LINES 200-203

Tracking Evolution Over Turns
-----------------------------
Let's now loop and let the auto-recomputing do its job.

.. GENERATED FROM PYTHON SOURCE LINES 203-240

.. code-block:: Python


    for turn in range(1, nturns):
        # This is not necessary, just for showcasing in this tutorial
        n_recomputes_for_auto = AUTO_IBS._number_of_coefficients_computations

        # ----- Potentially re-compute the IBS kick coefficients ----- #
        if (turn % ibs_step == 0) or (turn == 1):
            print(f"Turn {turn:d}: Fixed interval re-computing of coefficients")
            # Below always re-computes the coefficients every 'ibs_step' turns
            IBS.compute_kick_coefficients(particles)

        # ----- Manually Apply IBS Kick and Track Turn ----- #
        IBS.apply_ibs_kick(particles)
        AUTO_IBS.apply_ibs_kick(particles2)  # auto-recomputes if necessary
        line.track(particles, num_turns=1)
        line.track(particles2, num_turns=1)

        # ----- Update records for tracked particles ----- #
        regular.update_at_turn(turn, particles, twiss)
        auto.update_at_turn(turn, particles2, twiss)

        # ----- Check if the rates were auto-recomputed ----- #
        # This is also not necessary, just for showcasing in this tutorial
        if AUTO_IBS._number_of_coefficients_computations > n_recomputes_for_auto:
            print(f"At turn {turn} - Auto re-computed coefficients")
            auto_recomputes[turn - 1] = 1


    # Here we also aggregate the fixed recomputes
    for turn in turns:
        if (turn % ibs_step == 0) or (turn == 1):
            fixed_recomputes[turn - 1] = 1

    # And these are simply 1D arrays of the turns at which re-computing happened
    where_auto_recomputes = np.flatnonzero(auto_recomputes)
    where_fixed_recomputes = np.flatnonzero(fixed_recomputes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Turn 1: Fixed interval re-computing of coefficients
    At turn 2 - Auto re-computed coefficients
    At turn 8 - Auto re-computed coefficients
    At turn 9 - Auto re-computed coefficients
    At turn 11 - Auto re-computed coefficients
    At turn 14 - Auto re-computed coefficients
    At turn 15 - Auto re-computed coefficients
    At turn 25 - Auto re-computed coefficients
    At turn 26 - Auto re-computed coefficients
    At turn 29 - Auto re-computed coefficients
    At turn 35 - Auto re-computed coefficients
    At turn 39 - Auto re-computed coefficients
    At turn 43 - Auto re-computed coefficients
    At turn 45 - Auto re-computed coefficients
    At turn 48 - Auto re-computed coefficients
    Turn 50: Fixed interval re-computing of coefficients
    At turn 62 - Auto re-computed coefficients
    At turn 66 - Auto re-computed coefficients
    At turn 85 - Auto re-computed coefficients
    At turn 86 - Auto re-computed coefficients
    At turn 94 - Auto re-computed coefficients
    Turn 100: Fixed interval re-computing of coefficients
    At turn 102 - Auto re-computed coefficients
    At turn 107 - Auto re-computed coefficients
    At turn 108 - Auto re-computed coefficients
    At turn 113 - Auto re-computed coefficients
    At turn 117 - Auto re-computed coefficients
    At turn 127 - Auto re-computed coefficients
    At turn 131 - Auto re-computed coefficients
    At turn 134 - Auto re-computed coefficients
    At turn 145 - Auto re-computed coefficients
    At turn 147 - Auto re-computed coefficients
    At turn 148 - Auto re-computed coefficients
    Turn 150: Fixed interval re-computing of coefficients
    At turn 158 - Auto re-computed coefficients
    At turn 161 - Auto re-computed coefficients
    At turn 162 - Auto re-computed coefficients
    At turn 168 - Auto re-computed coefficients
    At turn 170 - Auto re-computed coefficients
    At turn 176 - Auto re-computed coefficients
    At turn 184 - Auto re-computed coefficients
    At turn 198 - Auto re-computed coefficients
    Turn 200: Fixed interval re-computing of coefficients
    At turn 201 - Auto re-computed coefficients
    At turn 206 - Auto re-computed coefficients
    At turn 208 - Auto re-computed coefficients
    At turn 231 - Auto re-computed coefficients
    At turn 248 - Auto re-computed coefficients
    Turn 250: Fixed interval re-computing of coefficients
    At turn 250 - Auto re-computed coefficients
    At turn 254 - Auto re-computed coefficients
    At turn 266 - Auto re-computed coefficients
    At turn 275 - Auto re-computed coefficients
    Turn 300: Fixed interval re-computing of coefficients
    At turn 302 - Auto re-computed coefficients
    At turn 308 - Auto re-computed coefficients
    At turn 310 - Auto re-computed coefficients
    At turn 311 - Auto re-computed coefficients
    At turn 312 - Auto re-computed coefficients
    At turn 332 - Auto re-computed coefficients
    At turn 334 - Auto re-computed coefficients
    Turn 350: Fixed interval re-computing of coefficients
    At turn 356 - Auto re-computed coefficients
    At turn 362 - Auto re-computed coefficients
    At turn 365 - Auto re-computed coefficients
    At turn 388 - Auto re-computed coefficients
    At turn 389 - Auto re-computed coefficients
    At turn 395 - Auto re-computed coefficients
    At turn 398 - Auto re-computed coefficients
    Turn 400: Fixed interval re-computing of coefficients
    At turn 416 - Auto re-computed coefficients
    At turn 417 - Auto re-computed coefficients
    At turn 422 - Auto re-computed coefficients
    At turn 438 - Auto re-computed coefficients
    At turn 441 - Auto re-computed coefficients
    At turn 445 - Auto re-computed coefficients
    At turn 448 - Auto re-computed coefficients
    Turn 450: Fixed interval re-computing of coefficients
    At turn 451 - Auto re-computed coefficients
    At turn 452 - Auto re-computed coefficients
    At turn 460 - Auto re-computed coefficients
    At turn 465 - Auto re-computed coefficients
    At turn 486 - Auto re-computed coefficients
    At turn 495 - Auto re-computed coefficients
    Turn 500: Fixed interval re-computing of coefficients
    At turn 521 - Auto re-computed coefficients
    Turn 550: Fixed interval re-computing of coefficients
    At turn 566 - Auto re-computed coefficients
    At turn 573 - Auto re-computed coefficients
    At turn 577 - Auto re-computed coefficients
    At turn 583 - Auto re-computed coefficients
    At turn 598 - Auto re-computed coefficients
    At turn 599 - Auto re-computed coefficients
    Turn 600: Fixed interval re-computing of coefficients
    At turn 607 - Auto re-computed coefficients
    At turn 625 - Auto re-computed coefficients
    At turn 635 - Auto re-computed coefficients
    At turn 639 - Auto re-computed coefficients
    At turn 643 - Auto re-computed coefficients
    At turn 645 - Auto re-computed coefficients
    Turn 650: Fixed interval re-computing of coefficients
    At turn 658 - Auto re-computed coefficients
    At turn 693 - Auto re-computed coefficients
    Turn 700: Fixed interval re-computing of coefficients
    At turn 703 - Auto re-computed coefficients
    At turn 717 - Auto re-computed coefficients
    At turn 729 - Auto re-computed coefficients
    At turn 735 - Auto re-computed coefficients
    At turn 738 - Auto re-computed coefficients
    At turn 740 - Auto re-computed coefficients
    Turn 750: Fixed interval re-computing of coefficients
    Turn 800: Fixed interval re-computing of coefficients
    At turn 806 - Auto re-computed coefficients
    At turn 811 - Auto re-computed coefficients
    At turn 812 - Auto re-computed coefficients
    At turn 818 - Auto re-computed coefficients
    At turn 821 - Auto re-computed coefficients
    At turn 838 - Auto re-computed coefficients
    At turn 839 - Auto re-computed coefficients
    At turn 840 - Auto re-computed coefficients
    At turn 841 - Auto re-computed coefficients
    At turn 845 - Auto re-computed coefficients
    Turn 850: Fixed interval re-computing of coefficients
    At turn 867 - Auto re-computed coefficients
    At turn 868 - Auto re-computed coefficients
    At turn 877 - Auto re-computed coefficients
    At turn 878 - Auto re-computed coefficients
    Turn 900: Fixed interval re-computing of coefficients
    At turn 919 - Auto re-computed coefficients
    At turn 921 - Auto re-computed coefficients
    At turn 932 - Auto re-computed coefficients
    At turn 940 - Auto re-computed coefficients
    Turn 950: Fixed interval re-computing of coefficients
    At turn 950 - Auto re-computed coefficients
    At turn 991 - Auto re-computed coefficients




.. GENERATED FROM PYTHON SOURCE LINES 241-242

Let's see how many recomputes happened in total for each scenario:

.. GENERATED FROM PYTHON SOURCE LINES 242-246

.. code-block:: Python


    print(f"Fixed re-computes: {IBS._number_of_coefficients_computations}")
    print(f"Auto re-computes: {AUTO_IBS._number_of_coefficients_computations}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Fixed re-computes: 21
    Auto re-computes: 116




.. GENERATED FROM PYTHON SOURCE LINES 247-250

That's almost four times as many updates of the coeffifients that were deemed
necessary by the auto-recomputing mechanism. Let's see the effect it has had
on our results by having a look at the evolution of emittances over time:

.. GENERATED FROM PYTHON SOURCE LINES 250-297

.. code-block:: Python


    AVG_TURNS = 3  # for rolling average plotting
    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    # We will add vertical lines at the times where recomputing of the kick 
    # coefficients happened (do this first so they show up in the background)
    for axis in axs.values():
        for turn in where_fixed_recomputes:
            axis.axvline(turn, color="gray", linestyle="--", lw=1, alpha=0.7)
        for turn in where_auto_recomputes:
            axis.axvline(turn, color="C1", linestyle="-", alpha=0.2)

    axs["epsx"].plot(turns, 1e10 * pd.Series(regular.epsilon_x).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["epsy"].plot(turns, 1e13 * pd.Series(regular.epsilon_y).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["sigd"].plot(turns, 1e3 * pd.Series(regular.sigma_delta).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")
    axs["bl"].plot(turns, 1e3 * pd.Series(regular.bunch_length).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=2, label=f"Fixed ({ibs_step}) turns")

    axs["epsx"].plot(turns, 1e10 * pd.Series(auto.epsilon_x).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["epsy"].plot(turns, 1e13 * pd.Series(auto.epsilon_y).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["sigd"].plot(turns, 1e3 * pd.Series(auto.sigma_delta).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["bl"].plot(turns, 1e3 * pd.Series(auto.bunch_length).rolling(AVG_TURNS, closed="both", min_periods=1).mean(), lw=1.9, label=f"Auto ({AUTO_PERCENT:.0f}% change)")

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$ [$10^{-10}$m]")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$ [$10^{-13}$m]")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$ [$10^{-3}$]")
    axs["bl"].set_ylabel(r"Bunch length [mm]")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Turn Number")

    for axis in axs.values():
        axis.yaxis.set_major_locator(plt.MaxNLocator(3))

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))
    fig.suptitle(f"Evolution of Emittances in CLIC DR (Kinetic Kicks)\nAverage of Last {AVG_TURNS} Turns")

    plt.legend(title="Recompute Coefficients")
    plt.tight_layout()
    plt.show()





.. image-sg:: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001.svg
   :alt: Evolution of Emittances in CLIC DR (Kinetic Kicks) Average of Last 3 Turns
   :srcset: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001.svg, /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_001_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 298-299

We can have a look at the relative change from turn to turn:

.. GENERATED FROM PYTHON SOURCE LINES 299-347

.. code-block:: Python


    fig, axs = plt.subplot_mosaic([["epsx", "epsy"], ["sigd", "bl"]], sharex=True, figsize=(13, 7))

    # We will add vertical lines at the times where recomputing of the kick 
    # coefficients happened (do this first so they show up in the background)
    for axis in axs.values():
        for turn in where_fixed_recomputes:
            axis.axvline(turn, color="gray", linestyle="--", lw=1, alpha=0.7)
        for turn in where_auto_recomputes:
            axis.axvline(turn, color="C1", linestyle="-", alpha=0.2)

    axs["epsx"].plot(turns, 1e2 * pd.Series(regular.epsilon_x).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["epsy"].plot(turns, 1e2 * pd.Series(regular.epsilon_y).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["sigd"].plot(turns, 1e2 * pd.Series(regular.sigma_delta).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")
    axs["bl"].plot(turns, 1e2 * pd.Series(regular.bunch_length).pct_change(), lw=1, label=f"Fixed ({ibs_step}) turns")

    axs["epsx"].plot(turns, 1e2 * pd.Series(auto.epsilon_x).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["epsy"].plot(turns, 1e2 * pd.Series(auto.epsilon_y).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["sigd"].plot(turns, 1e2 * pd.Series(auto.sigma_delta).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")
    axs["bl"].plot(turns, 1e2 * pd.Series(auto.bunch_length).pct_change(), lw=1, label=f"Auto ({AUTO_PERCENT:.0f}% change)")

    # Axes parameters
    axs["epsx"].set_ylabel(r"$\varepsilon_x$")
    axs["epsy"].set_ylabel(r"$\varepsilon_y$")
    axs["sigd"].set_ylabel(r"$\sigma_{\delta}$")
    axs["bl"].set_ylabel(r"Bunch length")

    for axis in (axs["epsy"], axs["bl"]):
        axis.yaxis.set_label_position("right")
        axis.yaxis.tick_right()

    for axis in (axs["sigd"], axs["bl"]):
        axis.set_xlabel("Duration [h]")

    for axis in axs.values():
        axis.axhline(AUTO_PERCENT, color="black", linestyle="--", alpha=0.5, label="Recompute Threshold")
        axis.yaxis.set_major_locator(plt.MaxNLocator(3))
        axis.set_yscale("log")

    fig.align_ylabels((axs["epsx"], axs["sigd"]))
    fig.align_ylabels((axs["epsy"], axs["bl"]))
    fig.suptitle("Percent change from previous turn")

    plt.legend(title="Recompute Coefficients")
    plt.tight_layout()
    plt.show()





.. image-sg:: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002.svg
   :alt: Percent change from previous turn
   :srcset: /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002.svg, /gallery/images/sphx_glr_demo_kicks_auto_recompute_coefficients_002_2_00x.svg 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 348-353

We can see that the auto-recompute feature leads to correct results of the IBS
effects in addition to making the tracking loop simpler to write. It also avoids
for the user to have to determine a proper interval for re-computing the kicks -
which could be correct for part of the simulation but not all of it - by adapting
itself to the actual changes in the particle distribution.

.. GENERATED FROM PYTHON SOURCE LINES 356-364

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~xibs.analytical`: `~.xibs.analytical.NagaitsevIBS`, `~.xibs.analytical.NagaitsevIBS.growth_rates`, `~.xibs.analytical.NagaitsevIBS.emittance_evolution`
   - `~xibs.inputs`: `~xibs.inputs.BeamParameters`, `~xibs.inputs.OpticsParameters`
   - `~xibs.kicks`: `~.xibs.kicks.DiffusionCoefficients`, `~.xibs.kicks.FrictionCoefficients`, `~.xibs.kicks.IBSKickCoefficients`, `~.xibs.kicks.KineticKickIBS`, `~.xibs.kicks.KineticKickIBS.apply_ibs_kick`, `~.xibs.kicks.KineticKickIBS.compute_kick_coefficients`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (4 minutes 41.258 seconds)


.. _sphx_glr_download_gallery_demo_kicks_auto_recompute_coefficients.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_kicks_auto_recompute_coefficients.ipynb <demo_kicks_auto_recompute_coefficients.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_kicks_auto_recompute_coefficients.py <demo_kicks_auto_recompute_coefficients.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
